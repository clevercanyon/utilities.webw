/**
 * `./package.json` build-related property updates.
 *
 * Vite is not aware of this config file's location.
 *
 * @note PLEASE DO NOT EDIT THIS FILE!
 * @note This entire file will be updated automatically.
 * @note Instead of editing here, please review <https://github.com/clevercanyon/skeleton>.
 */

import fs from 'node:fs';
import path from 'node:path';
import { $chalk } from '../../../../../node_modules/@clevercanyon/utilities.node/dist/index.js';
import { $mm, $obj } from '../../../../../node_modules/@clevercanyon/utilities/dist/index.js';
import extensions from '../../../bin/includes/extensions.mjs';
import u from '../../../bin/includes/utilities.mjs';

/**
 * Prepares `./package.json` build-related property updates.
 *
 * @param   props Props from vite config file driver.
 *
 * @returns       Build-related property updates.
 */
export default async ({
    command,
    isSSRBuild,
    projDir,
    srcDir,
    distDir,
    pkg,
    appType,
    targetEnv,
    sideEffects,
    appEntriesAsProjRelPaths,
    appEntriesAsSrcSubpaths,
    appEntriesAsSrcSubpathsNoExt,
}) => {
    const updates = {}; // Initialize.

    if (isSSRBuild) {
        updates.type = 'module'; // ESM; always.
        // Regarding `sideEffects`, {@see https://o5p.me/xVY39g}.
        updates.sideEffects = (pkg.sideEffects || []).concat(sideEffects);
    } else {
        updates.type = 'module'; // ESM; always.
        updates.exports = {}; // Exports object initialization.

        // Regarding `sideEffects`, {@see https://o5p.me/xVY39g}.
        updates.sideEffects = ['**/*.' + extensions.asBracedGlob([...extensions.byVSCodeLang.css, ...extensions.byVSCodeLang.scss, ...extensions.byVSCodeLang.less])];
        updates.sideEffects = updates.sideEffects.concat(sideEffects);

        if (fs.existsSync(path.resolve(srcDir, './resources/initialize.ts'))) {
            updates.sideEffects.push('./' + path.relative(projDir, path.resolve(srcDir, './resources/initialize.ts')));
        }
        if (['spa', 'mpa'].includes(appType) && fs.existsSync(path.resolve(srcDir, './resources/hydrate.tsx'))) {
            updates.sideEffects.push('./' + path.relative(projDir, path.resolve(srcDir, './resources/hydrate.tsx')));
        }
        const distDirAsProjRelPath = './' + path.relative(projDir, distDir); // Relative dist directory path.

        switch (true /* Conditional case handlers. */) {
            case ['spa', 'mpa'].includes(appType): {
                const canonicalHTMLExtRegExp = new RegExp('\\.' + extensions.asRegExpFrag([...extensions.byCanonical.html]) + '$', 'ui');
                const appEntryIndexAsSrcSubpath = appEntriesAsSrcSubpaths.find((subpath) =>
                    $mm.isMatch(subpath, 'index.' + extensions.asBracedGlob([...extensions.byCanonical.html])),
                );
                const appEntryIndexAsSrcSubpathNoExt = appEntryIndexAsSrcSubpath.replace(/\.[^.]+$/u, '');

                if (['spa'].includes(appType) && (!appEntryIndexAsSrcSubpath || !appEntryIndexAsSrcSubpathNoExt)) {
                    throw new Error('Single-page apps must have an `./index.' + extensions.asBracedGlob([...extensions.byCanonical.html]) + '` entry point.');
                    //
                } else if (['mpa'].includes(appType) && (!appEntryIndexAsSrcSubpath || !appEntryIndexAsSrcSubpathNoExt)) {
                    throw new Error('Multipage apps must have an `./index.' + extensions.asBracedGlob([...extensions.byCanonical.html]) + '` entry point.');
                }
                (updates.exports = null), (updates.typesVersions = {});
                updates.main = updates.module = updates.unpkg = updates.browser = updates.types = '';

                for (const appEntryAsProjRelPath of appEntriesAsProjRelPaths) {
                    if (canonicalHTMLExtRegExp.test(appEntryAsProjRelPath)) {
                        updates.sideEffects.push(appEntryAsProjRelPath); // The HTML file has side effects.
                        updates.sideEffects.push(appEntryAsProjRelPath.replace(canonicalHTMLExtRegExp, '.tsx'));

                        if (fs.existsSync(path.resolve(projDir, appEntryAsProjRelPath.replace(canonicalHTMLExtRegExp, '.scss')))) {
                            updates.sideEffects.push(appEntryAsProjRelPath.replace(canonicalHTMLExtRegExp, '.scss'));
                        }
                    }
                }
                break; // Stop here.
            }
            case ['cma', 'lib'].includes(appType): {
                const appEntryIndexAsSrcSubpath = appEntriesAsSrcSubpaths.find((subpath) =>
                    $mm.isMatch(subpath, 'index.' + extensions.asBracedGlob([...extensions.byDevGroup.sTypeScript, ...extensions.byDevGroup.sTypeScriptReact])),
                );
                const appEntryIndexAsSrcSubpathNoExt = appEntryIndexAsSrcSubpath.replace(/\.[^.]+$/u, '');

                if (['cma'].includes(appType) && (!appEntryIndexAsSrcSubpath || !appEntryIndexAsSrcSubpathNoExt)) {
                    throw new Error(
                        'Custom apps must have an `./index.' +
                            extensions.asBracedGlob([...extensions.byDevGroup.sTypeScript, ...extensions.byDevGroup.sTypeScriptReact]) +
                            '` entry point.',
                    );
                    //
                } else if (['lib'].includes(appType) && (!appEntryIndexAsSrcSubpath || !appEntryIndexAsSrcSubpathNoExt)) {
                    throw new Error(
                        'Library apps must have an `./index.' +
                            extensions.asBracedGlob([...extensions.byDevGroup.sTypeScript, ...extensions.byDevGroup.sTypeScriptReact]) +
                            '` entry point.',
                    );
                }
                updates.exports = {
                    '.': {
                        types: distDirAsProjRelPath + '/types/' + appEntryIndexAsSrcSubpathNoExt + '.d.ts', // First, always.
                        import: distDirAsProjRelPath + '/' + appEntryIndexAsSrcSubpathNoExt + '.js', // ESM module import path.
                        default: distDirAsProjRelPath + '/' + appEntryIndexAsSrcSubpathNoExt + '.js', // Last, always.
                    },
                };
                updates.main = distDirAsProjRelPath + '/' + appEntryIndexAsSrcSubpathNoExt + '.js';
                updates.module = distDirAsProjRelPath + '/' + appEntryIndexAsSrcSubpathNoExt + '.js';

                updates.unpkg = updates.module; // Same, same. ESM-only builds.
                updates.browser = ['web'].includes(targetEnv) ? updates.module : '';

                updates.typesVersions = { '>=3.1': { './*': [distDirAsProjRelPath + '/types/*'] } };
                updates.types = distDirAsProjRelPath + '/types/' + appEntryIndexAsSrcSubpathNoExt + '.d.ts';

                for (const appEntryAsSrcSubpathNoExt of [...appEntriesAsSrcSubpathsNoExt].sort()) {
                    if (appEntryAsSrcSubpathNoExt === appEntryIndexAsSrcSubpathNoExt) {
                        continue; // i.e., Itâ€™s already been defined as `.` above.
                    }
                    $obj.patchDeep(updates.exports, {
                        ['./' + appEntryAsSrcSubpathNoExt]: {
                            types: distDirAsProjRelPath + '/types/' + appEntryAsSrcSubpathNoExt + '.d.ts', // First, always.
                            import: distDirAsProjRelPath + '/' + appEntryAsSrcSubpathNoExt + '.js', // ESM module import path.
                            default: distDirAsProjRelPath + '/' + appEntryAsSrcSubpathNoExt + '.js', // Last, always.
                        },
                    });
                }
                break; // Stop here.
            }
            default: {
                throw new Error('Unexpected `appType`. Failed to update `./package.json` properties.');
            }
        }
    }
    updates.sideEffects = [...new Set(updates.sideEffects)].sort(); // Sorted unique values.

    if ('build' === command /* Only when building the app. */) {
        u.log($chalk.gray('Updating `type` and `sideEffects` in `./package.json`.'));
        await u.updatePkg({ $set: { type: updates.type, sideEffects: updates.sideEffects } });
    }
    return updates;
};
