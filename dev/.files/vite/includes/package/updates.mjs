/**
 * `./package.json` build-related property updates.
 *
 * Vite is not aware of this config file's location.
 *
 * @note PLEASE DO NOT EDIT THIS FILE!
 * @note This entire file will be updated automatically.
 * @note Instead of editing here, please review <https://github.com/clevercanyon/skeleton>.
 */

import fs from 'node:fs';
import path from 'node:path';
import { $chalk } from '../../../../../node_modules/@clevercanyon/utilities.node/dist/index.js';
import { $obj, $str } from '../../../../../node_modules/@clevercanyon/utilities/dist/index.js';
import extensions from '../../../bin/includes/extensions.mjs';
import u from '../../../bin/includes/utilities.mjs';

/**
 * Prepares `./package.json` build-related property updates.
 *
 * @param   props Props from vite config file driver.
 *
 * @returns       Build-related property updates.
 */
export default async ({ command, isSSRBuild, projDir, pkg, appType, targetEnv, appEntriesAsProjRelPaths, appEntriesAsSrcSubpaths, appEntriesAsSrcSubpathsNoExt }) => {
    const updates = {}; // Initialize.

    if (isSSRBuild) {
        updates.type = 'module'; // ESM; always.
        updates.sideEffects = pkg.sideEffects || []; // <https://o5p.me/xVY39g>.
    } else {
        updates.type = 'module'; // ESM; always.
        updates.exports = {}; // Exports object initialization.
        updates.sideEffects = []; // <https://o5p.me/xVY39g>.

        switch (true /* Conditional case handlers. */) {
            case ['spa', 'mpa'].includes(appType): {
                const appEntryIndexAsSrcSubpath = appEntriesAsSrcSubpaths.find((subpath) => $str.mm.isMatch(subpath, 'index.' + extensions.asBracedGlob([...extensions.trueHTML])));
                const appEntryIndexAsSrcSubpathNoExt = appEntryIndexAsSrcSubpath.replace(/\.[^.]+$/u, '');

                if (['spa'].includes(appType) && (!appEntryIndexAsSrcSubpath || !appEntryIndexAsSrcSubpathNoExt)) {
                    throw new Error('Single-page apps must have an `./index.' + extensions.asBracedGlob([...extensions.trueHTML]) + '` entry point.');
                    //
                } else if (['mpa'].includes(appType) && (!appEntryIndexAsSrcSubpath || !appEntryIndexAsSrcSubpathNoExt)) {
                    throw new Error('Multipage apps must have an `./index.' + extensions.asBracedGlob([...extensions.trueHTML]) + '` entry point.');
                }
                (updates.exports = null), (updates.typesVersions = {});
                updates.main = updates.module = updates.unpkg = updates.browser = updates.types = '';

                break; // Stop here.
            }
            case ['cma', 'lib'].includes(appType): {
                const appEntryIndexAsSrcSubpath = appEntriesAsSrcSubpaths.find((subpath) =>
                    $str.mm.isMatch(subpath, 'index.' + extensions.asBracedGlob([...extensions.sTypeScript, ...extensions.sTypeScriptReact])),
                );
                const appEntryIndexAsSrcSubpathNoExt = appEntryIndexAsSrcSubpath.replace(/\.[^.]+$/u, '');

                if (['cma'].includes(appType) && (!appEntryIndexAsSrcSubpath || !appEntryIndexAsSrcSubpathNoExt)) {
                    throw new Error('Custom apps must have an `./index.' + extensions.asBracedGlob([...extensions.sTypeScript, ...extensions.sTypeScriptReact]) + '` entry point.');
                    //
                } else if (['lib'].includes(appType) && (!appEntryIndexAsSrcSubpath || !appEntryIndexAsSrcSubpathNoExt)) {
                    throw new Error(
                        'Library apps must have an `./index.' + extensions.asBracedGlob([...extensions.sTypeScript, ...extensions.sTypeScriptReact]) + '` entry point.',
                    );
                }
                updates.exports = {
                    '.': {
                        types: './dist/types/' + appEntryIndexAsSrcSubpathNoExt + '.d.ts', // First, always.
                        import: './dist/' + appEntryIndexAsSrcSubpathNoExt + '.js', // ESM module import path.
                        default: './dist/' + appEntryIndexAsSrcSubpathNoExt + '.js', // Last, always.
                    },
                };
                updates.main = './dist/' + appEntryIndexAsSrcSubpathNoExt + '.js';
                updates.module = './dist/' + appEntryIndexAsSrcSubpathNoExt + '.js';

                updates.unpkg = updates.module; // Same, same. ESM-only builds.
                updates.browser = ['web'].includes(targetEnv) ? updates.module : '';

                updates.typesVersions = { '>=3.1': { './*': ['./dist/types/*'] } };
                updates.types = './dist/types/' + appEntryIndexAsSrcSubpathNoExt + '.d.ts';

                for (const appEntryAsSrcSubpathNoExt of appEntriesAsSrcSubpathsNoExt) {
                    if (appEntryAsSrcSubpathNoExt === appEntryIndexAsSrcSubpathNoExt) {
                        continue; // Don't remap the entry index.
                    }
                    $obj.patchDeep(updates.exports, {
                        ['./' + appEntryAsSrcSubpathNoExt]: {
                            types: './dist/types/' + appEntryAsSrcSubpathNoExt + '.d.ts', // First, always.
                            import: './dist/' + appEntryAsSrcSubpathNoExt + '.js', // ESM module import path.
                            default: './dist/' + appEntryAsSrcSubpathNoExt + '.js', // Last, always.
                        },
                    });
                }
                break; // Stop here.
            }
            default: {
                throw new Error('Unexpected `appType`. Failed to update `./package.json` properties.');
            }
        }
        if (fs.existsSync(path.resolve(projDir, './src/resources/init-env.ts'))) {
            updates.sideEffects.push('./src/resources/init-env.ts');
        }
    }
    for (const appEntryAsProjRelPath of appEntriesAsProjRelPaths) {
        const regExp = new RegExp('\\.' + extensions.asRegExpFrag([...extensions.trueHTML]) + '$', 'ug');
        updates.sideEffects.push(appEntryAsProjRelPath.replace(regExp, '.tsx'));
    }
    updates.sideEffects = [...new Set(updates.sideEffects)]; // Unique array values.

    if ('build' === command /* Only when building the app. */) {
        u.log($chalk.gray('Updating `type,sideEffects` in `./package.json`.'));
        await u.updatePkg({ $set: { type: updates.type, sideEffects: updates.sideEffects } });
    }
    return updates;
};
