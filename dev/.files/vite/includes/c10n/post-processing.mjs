/**
 * C10n post-processing plugin.
 *
 * Vite is not aware of this config file's location.
 *
 * @note PLEASE DO NOT EDIT THIS FILE!
 * @note This entire file will be updated automatically.
 * @note Instead of editing here, please review <https://github.com/clevercanyon/skeleton>.
 */

import fs from 'node:fs';
import fsp from 'node:fs/promises';
import path from 'node:path';
import { $http as $cfpꓺhttp } from '../../../../../node_modules/@clevercanyon/utilities.cfp/dist/index.js';
import { $chalk, $fs, $glob, $prettier } from '../../../../../node_modules/@clevercanyon/utilities.node/dist/index.js';
import { $crypto, $json, $mm, $obp, $preact, $str } from '../../../../../node_modules/@clevercanyon/utilities/dist/index.js';
import { StandAlone as StandAlone404 } from '../../../../../node_modules/@clevercanyon/utilities/dist/preact/components/404.js';
import exclusions from '../../../bin/includes/exclusions.mjs';
import extensions from '../../../bin/includes/extensions.mjs';
import u from '../../../bin/includes/utilities.mjs';

/**
 * Configures Vite post-processing plugin.
 *
 * @param   props Props from vite config file driver.
 *
 * @returns       Plugin configuration.
 */
export default async ({ mode, wranglerMode, inProdLikeMode, command, isSSRBuild, projDir, distDir, pkg, env, appBaseURL, appType, targetEnv, staticDefs, pkgUpdates }) => {
    let buildEndError = undefined, // Initialize.
        postProcessed = false; // Initialize.

    return {
        name: 'vite-plugin-c10n-post-processing',
        enforce: 'post', // After others on this hook.

        // Listens for build-related errors.
        // No post-processing if there were errors.
        buildEnd: (error) => void (buildEndError = error),

        async closeBundle(/* Rollup hook. */) {
            if (postProcessed || buildEndError) return;
            postProcessed = true; // Processing now.

            /**
             * Recompiles `./package.json`.
             */
            if (!isSSRBuild && 'build' === command) {
                u.log($chalk.gray('Recompiling `./package.json`.'));
                await u.updatePkg({ $set: pkgUpdates });
            }

            /**
             * Generates typescript type declaration file(s).
             */
            if (!isSSRBuild && 'build' === command /* Does important type checking at build time. */) {
                u.log($chalk.gray('Running TypeScript type checks.'));
                await u.spawn('npx', ['tsc']);
            }

            /**
             * Prunes `./.npmignore`s, which we don’t include in any distribution.
             *
             * We only prune `./.npmignore`s when building in a prod-like mode, as it’s possible there are files being
             * compiled by TypeScript that are needed for development; i.e., they need to exist in to be capable of
             * serving their intended purpose; e.g., dev-only utilities, runners, sandbox files, etc.
             *
             * Regarding `node_modules`. There is an exception for the case of `node_modules/assets/a16s` used for
             * Cloudflare SSR-specific assets. See `../a16s/dir.mjs` for details. By default, `node_modules` is pruned
             * by this routine because it’s in our default `./.npmignore`, which is why we need the exception below to
             * bypass pruning of `dist/node_modules/assets/a16s` following an SSR build. We also bypass pruning of files
             * in `dist/node_modules/.cache` following an SSR build, as deployment handlers may need these; e.g.,
             * Wrangler stores a few important-ish cache files there when deploying a `./dist` directory.
             *
             * We intentionally use our 'default' NPM ignores when pruning; i.e., as opposed to using the current and
             * potentially customized `./.npmignore` file in the current project directory. The reason is because we
             * intend to enforce our standards. For further details {@see https://o5p.me/MuskgW}.
             */
            if ('build' === command && inProdLikeMode) {
                const ignores = isSSRBuild
                    ? exclusions.defaultNPMIgnores // See notes above regarding these exceptions.
                          .concat(['!**/dist/node_modules/.cache/**', '!**/dist/node_modules/assets/a16s/**'])
                    : exclusions.defaultNPMIgnores.concat(['!**/dist/node_modules/.cache/**']);

                for (let globOpts = [{ onlyDirectories: true }, { onlyFiles: false }], i = 0; i < globOpts.length; i++) {
                    for (const fileOrDir of await $glob.promise(ignores, { cwd: distDir, ignoreCase: true, ...globOpts[i] })) {
                        const projRelPath = path.relative(projDir, fileOrDir);

                        if (!fs.existsSync(fileOrDir)) {
                            continue; // Already pruned this in a previous iteration.
                            // e.g., when we get directory parents first, then its leaves.
                        }
                        if (
                            // These things we expect to prune regularly.
                            // Anything else warrants more attention (see below).
                            $mm.test(
                                projRelPath,
                                [
                                    ...exclusions.devIgnores, //
                                    ...exclusions.sandboxIgnores,
                                    ...exclusions.exampleIgnores,
                                    ...exclusions.docIgnores,
                                    ...exclusions.testIgnores,
                                    ...exclusions.specIgnores,
                                    ...exclusions.benchIgnores,
                                ],
                                { ignoreCase: true, dot: true },
                            )
                        ) {
                            // These things we expect to prune regularly.
                            u.log($chalk.gray('Pruning `./' + projRelPath + '`.'));
                        } else {
                            // Anything else warrants more attention (yellow).
                            u.log($chalk.yellow('Pruning `./' + projRelPath + '`.'));
                        }
                        await fsp.rm(fileOrDir, { force: true, recursive: true });
                    }
                }
            }

            /**
             * Deletes a few things that are not needed by apps running on Cloudflare Pages.
             *
             * We only prune when building in a prod-like mode, as it’s possible there are files being compiled by
             * TypeScript that are needed for development; i.e., they need to exist in dev mode in order to be capable
             * of serving their intended purpose; e.g., dev-only utilities, runners, sandbox files, etc.
             */
            if ('build' === command && inProdLikeMode && ['spa', 'mpa'].includes(appType) && ['cfp'].includes(targetEnv)) {
                for (const fileOrDir of await $glob.promise(
                    [
                        'types', // Prunes TypeScript type declarations.
                        'index.' + extensions.asBracedGlob([...extensions.byCanonical.html]),
                    ],
                    { cwd: distDir, onlyFiles: false },
                )) {
                    u.log($chalk.gray('Pruning `./' + path.relative(projDir, fileOrDir) + '`.'));
                    await fsp.rm(fileOrDir, { force: true, recursive: true });
                }
            }

            /**
             * Updates a few files that configure apps running on Cloudflare Pages.
             *
             * None of these files must exist, and none of these must contain replacement codes. We leave it for the
             * implementation to decide. If they do not exist, or do not contain replacement codes, we assume that
             * nothing should occur. For example, it might be desirable in some cases for `./robots.txt`, `sitemap.xml`,
             * or others to be served dynamically. In which case they may not exist in these locations statically.
             */
            if (!isSSRBuild && 'build' === command && ['spa', 'mpa'].includes(appType) && ['cfp'].includes(targetEnv)) {
                const isC10n = env.APP_IS_C10N || false,
                    baseURL = appBaseURL, // Shorter alternative.
                    brand = await u.brand({ mode, baseURL });

                for (const file of await $glob.promise(
                    [
                        '.well-known/gpc.json',
                        '.well-known/gpg.txt',
                        '.well-known/security.txt',
                        '_headers',
                        '_redirects',
                        '_routes.json',
                        'sitemaps/**/*.xml',
                        'sitemap.xml',
                        'manifest.json',
                        'ads.txt',
                        'humans.txt',
                        'robots.txt',
                        '404.html',
                    ],
                    { cwd: distDir },
                )) {
                    const fileExt = $str.trim(path.extname(file), '.');
                    const fileRelPath = path.relative(distDir, file);

                    let fileContents = fs.readFileSync(file).toString(); // Reads file contents.

                    for (const key of Object.keys(staticDefs) /* Replaces all static definition tokens. */) {
                        fileContents = fileContents.replace(new RegExp($str.escRegExp(key), 'gu'), staticDefs[key]);
                    }
                    if (['.well-known/gpc.json'].includes(fileRelPath)) {
                        const cfpDefaultWellKnownGPCJSON = $cfpꓺhttp.prepareDefaultWellKnownGPCJSON({ appType, baseURL, brand, isC10n });
                        fileContents = fileContents
                            .replace('"$$__APP_CFP_DEFAULT_WELL_KNOWN_GPC_JSON__$$"', cfpDefaultWellKnownGPCJSON) //
                            .replace('$$__APP_CFP_DEFAULT_WELL_KNOWN_GPC_JSON__$$', cfpDefaultWellKnownGPCJSON);
                        //
                    } else if (['.well-known/gpg.txt'].includes(fileRelPath)) {
                        const cfpDefaultWellKnownGPGTxt = $cfpꓺhttp.prepareDefaultWellKnownGPGTxt({ appType, baseURL, brand, isC10n });
                        fileContents = fileContents.replace('$$__APP_CFP_DEFAULT_WELL_KNOWN_GPG_TXT__$$', cfpDefaultWellKnownGPGTxt);
                        //
                    } else if (['.well-known/security.txt'].includes(fileRelPath)) {
                        const cfpDefaultWellKnownSecurityTxt = $cfpꓺhttp.prepareDefaultWellKnownSecurityTxt({ appType, baseURL, brand, isC10n });
                        fileContents = fileContents.replace('$$__APP_CFP_DEFAULT_WELL_KNOWN_SECURITY_TXT__$$', cfpDefaultWellKnownSecurityTxt);
                        //
                    } else if (['_headers'].includes(fileRelPath)) {
                        const cfpDefaultHeaders = $cfpꓺhttp.prepareDefaultHeaders({ appType, baseURL, brand, isC10n });
                        fileContents = fileContents.replace('$$__APP_CFP_DEFAULT_HEADERS__$$', cfpDefaultHeaders);
                        //
                    } else if (['_redirects'].includes(fileRelPath)) {
                        const cfpDefaultRedirects = $cfpꓺhttp.prepareDefaultRedirects({ appType, baseURL, brand, isC10n });
                        fileContents = fileContents.replace('$$__APP_CFP_DEFAULT_REDIRECTS__$$', cfpDefaultRedirects);
                        //
                    } else if (['_routes.json'].includes(fileRelPath)) {
                        const cfpDefaultRoutesJSON = $cfpꓺhttp.prepareDefaultRoutesJSON({ appType, baseURL, brand, isC10n });
                        fileContents = fileContents
                            .replace('"$$__APP_CFP_DEFAULT_ROUTES_JSON__$$"', cfpDefaultRoutesJSON) //
                            .replace('$$__APP_CFP_DEFAULT_ROUTES_JSON__$$', cfpDefaultRoutesJSON);
                        //
                    } else if (['manifest.json'].includes(fileRelPath)) {
                        const cfpDefaultManifestJSON = $cfpꓺhttp.prepareDefaultManifestJSON({ appType, baseURL, brand, isC10n });
                        fileContents = fileContents
                            .replace('"$$__APP_CFP_DEFAULT_MANIFEST_JSON__$$"', cfpDefaultManifestJSON) //
                            .replace('$$__APP_CFP_DEFAULT_MANIFEST_JSON__$$', cfpDefaultManifestJSON);
                        //
                    } else if (['ads.txt'].includes(fileRelPath)) {
                        const cfpDefaultAdsTxt = $cfpꓺhttp.prepareDefaultAdsTxt({ appType, baseURL, brand, isC10n });
                        fileContents = fileContents.replace('$$__APP_CFP_DEFAULT_ADS_TXT__$$', cfpDefaultAdsTxt);
                        //
                    } else if (['humans.txt'].includes(fileRelPath)) {
                        const cfpDefaultHumansTxt = $cfpꓺhttp.prepareDefaultHumansTxt({ appType, baseURL, brand, isC10n });
                        fileContents = fileContents.replace('$$__APP_CFP_DEFAULT_HUMANS_TXT__$$', cfpDefaultHumansTxt);
                        //
                    } else if (['robots.txt'].includes(fileRelPath)) {
                        const cfpDefaultRobotsTxt = $cfpꓺhttp.prepareDefaultRobotsTxt({ appType, baseURL, brand, isC10n, allow: false });
                        fileContents = fileContents.replace('$$__APP_CFP_DEFAULT_ROBOTS_TXT__$$', cfpDefaultRobotsTxt);

                        const cfpDefaultAllowRobotsTxt = $cfpꓺhttp.prepareDefaultRobotsTxt({ appType, baseURL, brand, isC10n, allow: true });
                        fileContents = fileContents.replace('$$__APP_CFP_DEFAULT_ALLOW_ROBOTS_TXT__$$', cfpDefaultAllowRobotsTxt);
                        //
                    } else if (['404.html'].includes(fileRelPath)) {
                        const cfpDefault404 = '<!doctype html>' + $preact.ssr.renderToString($preact.create(StandAlone404));
                        fileContents = fileContents.replace('$$__APP_CFP_DEFAULT_404_HTML__$$', cfpDefault404);
                    }

                    if (['txt'].includes(fileExt) || ['_headers', '_redirects'].includes(fileRelPath)) {
                        fileContents = fileContents.replace(/^#[^\n]*\n/gmu, '');
                        //
                    } else if (['json'].includes(fileExt)) {
                        fileContents = fileContents.replace(/\/\*[\s\S]*?\*\/\n?/gu, '');
                        //
                    } else if (['xml', 'html'].includes(fileExt)) {
                        fileContents = fileContents.replace(/<!--[\s\S]*?-->\n?/gu, '');
                    }

                    fileContents = $str.trim(fileContents.replace(/\n{3,}/gu, '\n\n'));
                    u.log($chalk.gray('Updating `./' + path.relative(projDir, file) + '`.'));
                    await fsp.writeFile(file, fileContents);
                }
            }

            /**
             * Generates SHA-1 manifests for JS import compatibility.
             */
            if ('build' === command && fs.existsSync(path.resolve(distDir, './vite/' + (isSSRBuild ? 'ssr-' : '') + 'manifest.json'))) {
                u.log($chalk.gray('Generating MD5-keyed ' + (isSSRBuild ? 'SSR ' : '') + 'manifest.'));

                const file = path.resolve(distDir, './vite/' + (isSSRBuild ? 'ssr-' : '') + 'manifest.json');
                const data = $json.parse((await fsp.readFile(file)).toString());
                const sha1Data = {}; // Initialize.

                for (const [key, value] of Object.entries(data)) {
                    sha1Data['x' + (await $crypto.sha1(key))] = { [key]: value };
                }
                const prettierConfig = { ...(await $prettier.resolveConfig(file)), parser: 'json' };
                await fsp.writeFile(file, await $prettier.format($json.stringify(sha1Data, { pretty: true }), prettierConfig));
            }

            /**
             * Generates SSR build on-the-fly internally.
             */
            if (!isSSRBuild && 'build' === command && $obp.get(pkg, 'config.c10n.&.ssrBuild.appType')) {
                u.log($chalk.gray('Running secondary SSR build routine.'));
                await u.spawn('npx', ['vite', 'build', '--mode', mode, '--ssr']);
            }

            /**
             * Generates a zip archive containing `./dist` directory.
             */
            if (!isSSRBuild && 'build' === command && 'dev' !== wranglerMode) {
                const zipFile = path.resolve(projDir, './.~dist.zip');
                u.log($chalk.gray('Generating `' + path.relative(projDir, zipFile) + '`.'));

                const archive = $fs.archiver('zip', { zlib: { level: 9 } });
                archive.pipe(fs.createWriteStream(zipFile));
                archive.directory(distDir + '/', false);
                await archive.finalize();
            }
        },
    };
};
