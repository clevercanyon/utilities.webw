/**
 * Rollup config file.
 *
 * Rollup is not aware of this config file's location.
 *
 * @note PLEASE DO NOT EDIT THIS FILE!
 * @note This entire file will be updated automatically.
 * @note Instead of editing here, please review <https://github.com/clevercanyon/skeleton>.
 *
 * @see https://rollupjs.org/guide/en/#big-list-of-options
 * @see https://vitejs.dev/config/build-options.html#build-rollupoptions
 */

import path from 'node:path';
import { $json, $str } from '../../../../../node_modules/@clevercanyon/utilities/dist/index.js';

/**
 * Configures rollup for Vite.
 *
 * @param   props Props from vite config file driver.
 *
 * @returns       Rollup configuration.
 */
export default async ({ srcDir, distDir, a16sDir, appEntries, peerDepKeys, preserveModules, useMinifier, useUMD }) => {
    const entryCounters = new Map(),
        chunkCounters = new Map();

    return {
        input: appEntries,

        external: [
            ...peerDepKeys.map((k) => new RegExp('^' + $str.escRegExp(k) + '(?:$|[/?])')),
            '__STATIC_CONTENT_MANIFEST', // Cloudflare worker sites use this for static assets.
        ],
        output: {
            interop: 'auto', // Matches TypeScript config.
            exports: 'named', // Matches TypeScript config.
            esModule: true, // Matches TypeScript config.

            extend: true, // i.e., UMD global `||` checks.
            noConflict: true, // Behaves the same as `jQuery.noConflict()`.
            compact: useMinifier, // Minify wrapper code generated by rollup?

            // By default, special chars in a path like `[[name]].js` get changed to `__name__.js`.
            // This prevents that by enforcing a custom sanitizer. See: <https://o5p.me/Y2fNf9> for details.
            sanitizeFileName: (fileName) => fileName.replace(/[\0?*]/gu, ''),

            // By default, in SSR mode, Vite forces all entry files into the distDir root.
            // This prevents that by enforcing a consistently relative location for all entries.
            entryFileNames: (entry) => {
                // This function doesn’t have access to the current output format, unfortunately.
                // However, we are setting `build.lib.formats` explicitly in the configuration below.
                // Therefore, we know `es` comes first, followed by either `umd` or `cjs` output entries.
                // So, entry counters make it possible to infer build output format, based on sequence.

                const entryKey = $json.stringify(entry); // JSON serialization.
                const entryCounter = Number(entryCounters.get(entryKey) || 0) + 1;

                const entryFormat = entryCounter > 1 ? (useUMD ? 'umd' : 'cjs') : 'es';
                const entryExt = 'umd' === entryFormat ? 'umd.cjs' : 'cjs' === entryFormat ? 'cjs' : 'js';

                entryCounters.set(entryKey, entryCounter); // Updates counter.

                if ('.html' === path.extname(entry.facadeModuleId)) {
                    if (/\//u.test(entry.name)) return '[name]-[hash].' + entryExt;
                    return path.join(path.relative(distDir, a16sDir), '[name]-[hash].' + entryExt);
                }
                if (/\//u.test(entry.name)) return '[name].' + entryExt; // Already a subpath.
                return path.join(path.relative(srcDir, path.dirname(entry.facadeModuleId)), '[name].' + entryExt);
            },

            // By default, in library mode, Vite ignores `build.assetsDir`.
            // This prevents that by enforcing a consistent location for chunks and assets.
            chunkFileNames: (chunk) => {
                // This function doesn’t have access to the current output format, unfortunately.
                // However, we are setting `build.lib.formats` explicitly in the configuration below.
                // Therefore, we know `es` comes first, followed by either `umd` or `cjs` output chunks.
                // So, chunk counters make it possible to infer build output format, based on sequence.

                const chunkKey = $json.stringify(chunk); // JSON serialization.
                const chunkCounter = Number(chunkCounters.get(chunkKey) || 0) + 1;

                const chunkFormat = chunkCounter > 1 ? (useUMD ? 'umd' : 'cjs') : 'es';
                const chunkExt = 'umd' === chunkFormat ? 'umd.cjs' : 'cjs' === chunkFormat ? 'cjs' : 'js';

                chunkCounters.set(chunkKey, chunkCounter); // Updates counter.
                return path.join(path.relative(distDir, a16sDir), '[name]-[hash].' + chunkExt);
            },
            assetFileNames: (/* asset */) => path.join(path.relative(distDir, a16sDir), '[name]-[hash].[ext]'),

            // Preserves module structure in apps built explicitly as multi-entry libraries.
            // The expectation is that its peers will build w/ this flag set as false, which is
            // recommended, because preserving module structure in a final build has performance costs.
            // However, in builds that are not final (e.g., apps with peer dependencies), preserving modules
            // has performance benefits, as it allows for tree-shaking optimization in final builds.
            ...(preserveModules ? { preserveModules: true } : {}),

            // Cannot inline dynamic imports when `preserveModules` is enabled, so set as `false` explicitly.
            ...(preserveModules ? { inlineDynamicImports: false } : {}),
        },
    };
};
