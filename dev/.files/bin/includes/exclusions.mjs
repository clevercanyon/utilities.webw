/**
 * Exclusions.
 *
 * @note PLEASE DO NOT EDIT THIS FILE!
 * @note This entire file will be updated automatically.
 * @note Instead of editing here, please review <https://github.com/clevercanyon/skeleton>.
 */

import path from 'node:path';
import { $obj, $path, $str } from '../../../../node_modules/@clevercanyon/utilities/dist/index.js';

/**
 * Converts an array of exclusions into regular expression strings.
 *
 * @param   globs Array of exclusion globs.
 *
 * @returns       Exclusions as regular expression strings.
 */
const asRegExpStrings = (globs) => [...new Set(globs)].map((glob) => $path.globToRegExpString(glob));

/**
 * Converts an array of exclusions into regular expressions.
 *
 * @param   globs Array of exclusion globs.
 *
 * @returns       Exclusions as regular expressions.
 */
const asRegExps = (globs) => asRegExpStrings(globs).map((rxs) => new RegExp(rxs, 'ui'));

/**
 * Converts an array of exclusions into negated globs.
 *
 * WARNING: This typically drops existing negations, based on options.
 *
 * @param   globs   Array of exclusion globs.
 * @param   options Explicit options required for acknowledgment of concerns.
 *
 * @returns         Exclusions as negated globs; potentially dropping existing negations.
 *
 * @note If existing negations are not dropped, they become inclusions, typically causing problems.
 *       Normally, we don’t need to re-include the existing negations, as they are narrower in scope.
 */
const asNegatedGlobs = (globs, { dropExistingNegations }) => {
    if (undefined === dropExistingNegations) {
        throw new Error('Missing option: `dropExistingNegations`.');
    }
    if (dropExistingNegations) {
        return [...new Set(globs)].filter((glob) => !/^!/u.test(glob)).map((glob) => '!' + glob);
    }
    return [...new Set(globs)].map((glob) => (/^!/u.test(glob) ? glob.replace(/^!/u, '') : '!' + glob));
};

/**
 * Converts an array of exclusions into relative globs.
 *
 * @param   from    From path.
 * @param   globs   Array of exclusion globs.
 * @param   options Options related to relative globs.
 *
 * @returns         Exclusions as relative globs.
 */
const asRelativeGlobs = (from, globs, { forceRelative = false, forceNoLeadingSlash = false, headGreedy = true, tailGreedy = true } = {}) => {
    return [...new Set(globs)].map((glob) => {
        glob = glob.replace(/^(?:\*\*\/)+|(?:\/\*\*)+$/gu, '');
        glob = headGreedy && !/\//u.test(glob) ? '**/' + glob : glob;
        glob = tailGreedy ? glob + '/**' : glob;
        glob = forceRelative ? glob.replace(/^(?:\*\*\/)+/u, '') : glob;
        glob = forceNoLeadingSlash ? glob.replace(/^\/+/u, '') : glob;
        return /^(?:\/|\*\*\/)/u.test(glob) ? glob : path.relative(from, glob);
    });
};

/**
 * Converts an array of exclusions into rooted relative globs.
 *
 * @param   from    From path.
 * @param   globs   Array of exclusion globs.
 * @param   options Options related to relative globs.
 *
 * @returns         Exclusions as rooted relative globs.
 */
const asRootedRelativeGlobs = (from, globs, { forceRelative = false, forceNoLeadingSlash = false, headGreedy = true, tailGreedy = true } = {}) => {
    return [...new Set(globs)].map((glob) => {
        glob = glob.replace(/^(?:\*\*\/)+|(?:\/\*\*)+$/gu, '');
        glob = headGreedy && !/\//u.test(glob) ? '**/' + glob : glob;
        glob = tailGreedy ? glob + '/**' : glob;
        glob = forceRelative ? glob.replace(/^(?:\*\*\/)+/u, '') : glob;
        glob = forceNoLeadingSlash ? glob.replace(/^\/+/u, '') : glob;
        return /^(?:\/|\*\*\/)/u.test(glob) ? glob : '/' + $str.lTrim(path.relative(from, glob), '/');
    });
};

/**
 * Converts an array of exclusions into a braced glob.
 *
 * WARNING: This always drops existing negations & relative exclusions.
 *
 * @param   globs   Array of exclusion globs.
 * @param   options Explicit options required for acknowledgment of concerns.
 *
 * @returns         Exclusions as braced glob; potentially dropping negations & relative exclusions.
 *
 * @note `dropExistingNegations` can *only* be set as true. There’s no other way to handle.
 * @note `maybeDropExistingRelatives` can *only* be set as true. There’s no other way to handle.
 */
const asBracedGlob = (globs, { dropExistingNegations, maybeDropExistingRelatives, headGreedy = true, tailGreedy = true }) => {
    if (true !== dropExistingNegations) {
        throw new Error('Missing option: `dropExistingNegations`; must be `true`.');
    }
    if (true !== maybeDropExistingRelatives) {
        throw new Error('Missing option: `maybeDropExistingRelatives`; must be `true`.');
    }
    let bracedGlobs = []; // Initialize.

    [...new Set(globs)].forEach((glob) => {
        if (dropExistingNegations && /^!/u.test(glob)) return;

        glob = glob.replace(/^(?:\*\*\/)+|(?:\/\*\*)+$/gu, '');
        if (maybeDropExistingRelatives && headGreedy && /^\//u.test(glob)) return;

        bracedGlobs.push(glob); // OK, we can add to braces below.
    });
    bracedGlobs = [...new Set(bracedGlobs)]; // Unique again, after processing.

    return (
        (headGreedy ? '**/' : '') + //
        (bracedGlobs.length > 1 ? '{' : '') +
        bracedGlobs.join(',') + // Concatenate.
        (bracedGlobs.length > 1 ? '}' : '') +
        (tailGreedy ? '/**' : '')
    );
};

/**
 * Converts an array of exclusions into boolean properties.
 *
 * @param   globs   Array of of exclusion globs.
 * @param   options Default is `{ tailGreedy: true }`.
 *
 * @returns         Exclusions as boolean properties.
 */
const asBoolProps = (globs, { headGreedy = true, tailGreedy = true } = {}) => {
    const props = {}; // Initialize.

    for (let glob of globs) {
        const isNegated = /^!/u.test(glob);

        if (isNegated /* Remove in favor of bool props. */) {
            glob = glob.replace(/^!/u, '');
        }
        glob = glob.replace(/^(?:\*\*\/)+|(?:\/\*\*)+$/gu, '');
        glob = headGreedy && !/\//u.test(glob) ? '**/' + glob : glob;
        glob = tailGreedy ? glob + '/**' : glob;

        props[glob] = isNegated ? false : true;
    }
    return props; // Plain object properties.
};

/**
 * Defines exclusions globs.
 *
 * Note: `{}` brace expansions are not compatible with TypeScript’s config file. Everything listed here should follow
 * `.gitignore|.npmignore` syntax first, then be converted from `.gitignore` into a fast-glob pattern.
 */
export default {
    /**
     * Default Git/NPM ignores, by category. Categories added to the default export here. Provided by
     * `@clevercanyon/utilities`. Includes everything we have in our default `./.gitignore`, `./.npmignore`.
     */
    ...$obj.map($path.defaultGitNPMIgnoresByCategory(), (category) => {
        return category.map((gitIgnore) => $path.gitIgnoreToGlob(gitIgnore));
    }),

    /**
     * We intentionally use our 'default' NPM ignores when pruning; i.e., as opposed to using the current and
     * potentially customized `./.npmignore` file in the current project directory. The reason is because we intend to
     * enforce our standards. For further details {@see https://o5p.me/MuskgW}.
     */
    defaultNPMIgnores: $path.defaultNPMIgnores().map((npmIgnore) => {
        return $path.gitIgnoreToGlob(npmIgnore);
    }),

    /**
     * Specifically for use in our projects.
     */
    adhocXIgnores: ['**/x-*/**'], // For special use cases.

    /**
     * Utilities.
     */
    asRegExps,
    asRegExpStrings,
    asNegatedGlobs,
    asRelativeGlobs,
    asRootedRelativeGlobs,
    asBracedGlob,
    asBoolProps,
};
