#!/usr/bin/env node
/**
 * Update CLI.
 *
 * @note PLEASE DO NOT EDIT THIS FILE!
 * @note This entire file will be updated automatically.
 * @note Instead of editing here, please review <https://github.com/clevercanyon/skeleton>.
 */

import fs from 'node:fs';
import fsp from 'node:fs/promises';
import path from 'node:path';
import { $chalk, $cmd, $glob, $yargs } from '../../../node_modules/@clevercanyon/utilities.node/dist/index.js';
import { $mm } from '../../../node_modules/@clevercanyon/utilities/dist/index.js';
import u from '../resources/utilities.mjs';

/**
 * VS Code command.
 */
class VSCode {
    /**
     * Constructor.
     */
    constructor(args) {
        this.args = args;
    }

    /**
     * Runs CMD.
     */
    async run() {
        await this.#update();

        if (this.args.dryRun) {
            u.log($chalk.cyanBright('Dry run. This was all a simulation.'));
        }
    }

    /**
     * Runs update.
     */
    async #update() {
        /**
         * Recompiles `./.vscode/settings.json` file.
         */

        u.log($chalk.green('Updating `./.vscode`.'));
        if (!this.args.dryRun) {
            await (await import('./updater/resources/updaters/vscode/index.mjs')).default({ projDir: u.projDir });
        }

        /**
         * Signals completion with success.
         */

        u.log(await u.finaleBox('Success', 'VS Code config update complete.'));
    }
}

/**
 * Git attributes command.
 */
class GitAttributes {
    /**
     * Constructor.
     */
    constructor(args) {
        this.args = args;
    }

    /**
     * Runs CMD.
     */
    async run() {
        await this.#update();

        if (this.args.dryRun) {
            u.log($chalk.cyanBright('Dry run. This was all a simulation.'));
        }
    }

    /**
     * Runs update.
     */
    async #update() {
        /**
         * Recompiles `./.gitattributes` file.
         */

        u.log($chalk.green('Updating `./.gitattributes`.'));
        if (!this.args.dryRun) {
            await (await import('./updater/resources/updaters/gitattributes/index.mjs')).default({ projDir: u.projDir });
        }

        /**
         * Signals completion with success.
         */

        u.log(await u.finaleBox('Success', '`./.gitattributes` update complete.'));
    }
}

/**
 * Git ignore command.
 */
class GitIgnore {
    /**
     * Constructor.
     */
    constructor(args) {
        this.args = args;
    }

    /**
     * Runs CMD.
     */
    async run() {
        await this.#update();

        if (this.args.dryRun) {
            u.log($chalk.cyanBright('Dry run. This was all a simulation.'));
        }
    }

    /**
     * Runs update.
     */
    async #update() {
        /**
         * Recompiles `./.gitignore` file.
         */

        u.log($chalk.green('Updating `./.gitignore`.'));
        if (!this.args.dryRun) {
            await (await import('./updater/resources/updaters/gitignore/index.mjs')).default({ projDir: u.projDir });
        }

        /**
         * Signals completion with success.
         */

        u.log(await u.finaleBox('Success', '`./.gitignore` update complete.'));
    }
}

/**
 * NPM ignore command.
 */
class NPMIgnore {
    /**
     * Constructor.
     */
    constructor(args) {
        this.args = args;
    }

    /**
     * Runs CMD.
     */
    async run() {
        await this.#update();

        if (this.args.dryRun) {
            u.log($chalk.cyanBright('Dry run. This was all a simulation.'));
        }
    }

    /**
     * Runs update.
     */
    async #update() {
        /**
         * Recompiles `./.npmignore` file.
         */

        u.log($chalk.green('Updating `./.npmignore`.'));
        if (!this.args.dryRun) {
            await (await import('./updater/resources/updaters/npmignore/index.mjs')).default({ projDir: u.projDir });
        }

        /**
         * Signals completion with success.
         */

        u.log(await u.finaleBox('Success', '`./.npmignore` update complete.'));
    }
}

/**
 * Docker ignore command.
 */
class DockerIgnore {
    /**
     * Constructor.
     */
    constructor(args) {
        this.args = args;
    }

    /**
     * Runs CMD.
     */
    async run() {
        await this.#update();

        if (this.args.dryRun) {
            u.log($chalk.cyanBright('Dry run. This was all a simulation.'));
        }
    }

    /**
     * Runs update.
     */
    async #update() {
        /**
         * Recompiles `./.dockerignore` file.
         */

        u.log($chalk.green('Updating `./.dockerignore`.'));
        if (!this.args.dryRun) {
            await (await import('./updater/resources/updaters/dockerignore/index.mjs')).default({ projDir: u.projDir });
        }

        /**
         * Signals completion with success.
         */

        u.log(await u.finaleBox('Success', '`./.dockerignore` update complete.'));
    }
}

/**
 * VS Code ignore command.
 */
class VSCodeIgnore {
    /**
     * Constructor.
     */
    constructor(args) {
        this.args = args;
    }

    /**
     * Runs CMD.
     */
    async run() {
        await this.#update();

        if (this.args.dryRun) {
            u.log($chalk.cyanBright('Dry run. This was all a simulation.'));
        }
    }

    /**
     * Runs update.
     */
    async #update() {
        /**
         * Recompiles `./.vscodeignore` file.
         */

        u.log($chalk.green('Updating `./.vscodeignore`.'));
        if (!this.args.dryRun) {
            await (await import('./updater/resources/updaters/vscodeignore/index.mjs')).default({ projDir: u.projDir });
        }

        /**
         * Signals completion with success.
         */

        u.log(await u.finaleBox('Success', '`./.vscodeignore` update complete.'));
    }
}

/**
 * Prettier ignore command.
 */
class PrettierIgnore {
    /**
     * Constructor.
     */
    constructor(args) {
        this.args = args;
    }

    /**
     * Runs CMD.
     */
    async run() {
        await this.#update();

        if (this.args.dryRun) {
            u.log($chalk.cyanBright('Dry run. This was all a simulation.'));
        }
    }

    /**
     * Runs update.
     */
    async #update() {
        /**
         * Recompiles `./.prettierignore` file.
         */

        u.log($chalk.green('Updating `./.prettierignore`.'));
        if (!this.args.dryRun) {
            await (await import('./updater/resources/updaters/prettierignore/index.mjs')).default({ projDir: u.projDir });
        }

        /**
         * Signals completion with success.
         */

        u.log(await u.finaleBox('Success', '`./.prettierignore` update complete.'));
    }
}

/**
 * Browserslist command.
 */
class Browserslist {
    /**
     * Constructor.
     */
    constructor(args) {
        this.args = args;
    }

    /**
     * Runs CMD.
     */
    async run() {
        await this.#update();

        if (this.args.dryRun) {
            u.log($chalk.cyanBright('Dry run. This was all a simulation.'));
        }
    }

    /**
     * Runs update.
     */
    async #update() {
        /**
         * Recompiles `./.browserslistrc` file.
         */

        u.log($chalk.green('Updating `./.browserslistrc`.'));
        if (!this.args.dryRun) {
            await (await import('./updater/resources/updaters/browserslist/index.mjs')).default({ projDir: u.projDir });
        }

        /**
         * Signals completion with success.
         */

        u.log(await u.finaleBox('Success', '`./.browserslistrc` update complete.'));
    }
}

/**
 * TS config command.
 */
class TSConfig {
    /**
     * Constructor.
     */
    constructor(args) {
        this.args = args;
    }

    /**
     * Runs CMD.
     */
    async run() {
        await this.#update();

        if (this.args.dryRun) {
            u.log($chalk.cyanBright('Dry run. This was all a simulation.'));
        }
    }

    /**
     * Runs update.
     */
    async #update() {
        /**
         * Recompiles `./tsconfig.json` file.
         */

        u.log($chalk.green('Updating `./tsconfig.json`.'));
        if (!this.args.dryRun) {
            await (await import('./updater/resources/updaters/tsconfig/index.mjs')).default({ projDir: u.projDir });
        }

        /**
         * Signals completion with success.
         */

        u.log(await u.finaleBox('Success', 'TypeScript config update complete.'));
    }
}

/**
 * Wrangler command.
 */
class Wrangler {
    /**
     * Constructor.
     */
    constructor(args) {
        this.args = args;
    }

    /**
     * Runs CMD.
     */
    async run() {
        await this.#update();

        if (this.args.dryRun) {
            u.log($chalk.cyanBright('Dry run. This was all a simulation.'));
        }
    }

    /**
     * Runs update.
     */
    async #update() {
        /**
         * Recompiles `./wrangler.toml` file.
         */

        u.log($chalk.green('Updating `./wrangler.toml`.'));
        if (!this.args.dryRun) {
            await (await import('./updater/resources/updaters/wrangler/index.mjs')).default({ projDir: u.projDir });
        }

        /**
         * Signals completion with success.
         */

        u.log(await u.finaleBox('Success', 'Wrangler config update complete.'));
    }
}

/**
 * Dotfiles command.
 */
class Dotfiles {
    /**
     * Constructor.
     */
    constructor(args) {
        this.args = args;
    }

    /**
     * Runs CMD.
     */
    async run() {
        await this.#update();

        if (this.args.dryRun) {
            u.log($chalk.cyanBright('Dry run. This was all a simulation.'));
        }
    }

    /**
     * Runs update.
     */
    async #update() {
        /**
         * Skeleton.
         */

        let branch = 'main'; // Default branch.

        if (await u.isPkgName(u.projects.skeleton.pkgName)) {
            if (!(await u.isGitRepo())) {
                throw new Error('`' + u.projects.skeleton.pkgName + '` is not a git repo.');
            }
            branch = await u.gitCurrentBranch();
            // In a self-update scenario, always use the current branch.
            // Otherwise, the current branch would be wiped out by files from a different branch.
            // i.e., So we can work on a different branch and still have the ability to run a self-update.
        }
        const repoURL = u.projects.skeleton.repoURL; // From core projects.
        const repoDir = path.resolve(u.projects.skeleton.tmpDir, './' + branch);
        const repoDfBinDir = path.resolve(repoDir, u.projects.paths.relDfBinDir);

        /**
         * Saves any pending changes; else checks state.
         */

        if ((await u.isPkgName(u.projects.skeleton.pkgName)) && (await u.isGitRepoDirty())) {
            u.log($chalk.green('Updating `' + u.projects.skeleton.pkgName + '` git repo; `' + branch + '` branch.'));
            u.log('    ' + $chalk.green('i.e., saving latest ' + u.projects.skeleton.pkgName + ' changes before self-update.'));

            if (!this.args.dryRun) {
                await u.gitAddCommitPush((this.args.message + ' [d]').trim());
            }
        } else if (await u.isPkgName(u.projects.skeleton.pkgName)) {
            if ((await u.gitLocalRepoSHA(u.projDir, branch)) !== (await u.gitRemoteRepoSHA(repoURL, branch))) {
                throw new Error('`' + u.projects.skeleton.pkgName + '` is out of sync with git remote origin; `' + branch + '` branch.');
            }
        }

        /**
         * Prepares latest skeleton.
         */

        if (fs.existsSync(repoDir) && (await u.gitLocalRepoSHA(repoDir, branch)) === (await u.gitRemoteRepoSHA(repoURL, branch))) {
            u.log($chalk.green('Using latest `' + u.projects.skeleton.pkgName + '` from cache; `' + branch + '` branch.'));
        } else {
            u.log($chalk.green('Git-cloning, and caching, latest `' + u.projects.skeleton.pkgName + '`; `' + branch + '` branch.'));
            if (!this.args.dryRun) {
                await fsp.rm(repoDir, { recursive: true, force: true });
                await fsp.mkdir(repoDir, { recursive: true }); // Starts fresh.
                await u.spawn('git', ['clone', repoURL, repoDir, '--branch', branch, '--depth=1'], { cwd: repoDir });
            }
            u.log($chalk.green('Installing `' + u.projects.skeleton.pkgName + '`’s NPM dependencies; `' + branch + '` branch.'));
            if (!this.args.dryRun) {
                await u.spawn('npm', ['ci'], { cwd: repoDir });
            }
        }

        /**
         * Runs updater using files from latest skeleton.
         */

        u.log($chalk.green('Running updater using latest `' + u.projects.skeleton.pkgName + '`; `' + branch + '` branch.'));
        if (!this.args.dryRun) {
            await (await import(path.resolve(repoDfBinDir, './updater/index.mjs'))).default({ projDir: u.projDir });
        }

        /**
         * Signals completion with success.
         */

        u.log(await u.finaleBox('Success', 'Dotfiles update complete.'));
    }
}

/**
 * Project command.
 */
class Project {
    /**
     * Constructor.
     */
    constructor(args) {
        this.args = args;
    }

    /**
     * Runs CMD.
     */
    async run() {
        await this.#update();

        if (this.args.dryRun) {
            u.log($chalk.cyanBright('Dry run. This was all a simulation.'));
        }
    }

    /**
     * Runs update.
     */
    async #update() {
        /**
         * Updates NPM packages.
         */

        u.log($chalk.green('Updating NPM packages.'));
        if (!this.args.dryRun) {
            await u.npmUpdate({ directive: this.args.npm });
        }

        /**
         * Checks org-wide GitHub repo standards.
         */

        if (this.args.repos && (await u.isGitRepo()) && (await u.isGitRepoOriginGitHub())) {
            u.log($chalk.green('Repos will update, so checking GitHub repo org-wide standards.'));
            await u.githubCheckRepoOrgWideStandards({ dryRun: this.args.dryRun });
        }

        /**
         * Pushes Dotenv Vault envs and syncs repo environments.
         */

        if (this.args.repos && (await u.isEnvsVault())) {
            u.log($chalk.green('Repos will update, so pushing all Dotenv Vault envs.'));
            // Also syncs GitHub repo environments using org-wide standards.
            await u.envsPush({ dryRun: this.args.dryRun });
        }

        /**
         * Increments a publishable NPM package version.
         */

        if (this.args.repos && this.args.pkgs && (await u.isNPMPkgPublishable({ mode: this.args.mode }))) {
            u.log($chalk.green('NPM package will publish, so incrementing version.'));
            await u.pkgIncrementVersion({ dryRun: this.args.dryRun });
        }

        /**
         * Updates Vite build in the given mode.
         */

        if (await u.isViteBuild()) {
            u.log($chalk.green('Updating Vite build; `' + this.args.mode + '` mode.'));
            if (!this.args.dryRun) {
                await u.viteBuild({ mode: this.args.mode });
            }
        }

        /**
         * Updates repos and potentially publishes packages.
         */

        if (this.args.repos) {
            /**
             * Publishes a new version of NPM package(s).
             */

            if (this.args.pkgs) {
                if (await u.isNPMPkgPublishable({ mode: this.args.mode })) {
                    u.log($chalk.green('Publishing NPM package.'));
                    // Also checks org-wide npmjs package standards.
                    await u.npmPublish({ dryRun: this.args.dryRun });
                    //
                } else if (await u.isNPMPkg()) {
                    u.log($chalk.gray('NPM package is not in a publishable state.'));
                } else {
                    u.log($chalk.gray('Not an NPM package.'));
                }
            }

            /**
             * Pushes changes to git repo(s).
             */

            if (await u.isGitRepo()) {
                if (await u.isGitRepoDirty()) {
                    u.log($chalk.green('Committing git repo changes; `' + (await u.gitCurrentBranch()) + '` branch.'));
                    if (!this.args.dryRun) {
                        await u.gitAddCommit((this.args.message + ' [p]').trim());
                    }
                }
                if (this.args.pkgs && (await u.isNPMPkgPublishable({ mode: this.args.mode }))) {
                    u.log($chalk.green('Creating git repo tag; `' + (await u.gitCurrentBranch()) + '` branch; `v' + u.pkgVersion + '` tag.'));
                    if (!this.args.dryRun) {
                        await u.gitTag((this.args.message + ' [p][v' + u.pkgVersion + ']').trim());
                    }
                }
                u.log($chalk.green('Pushing to git repo; `' + (await u.gitCurrentBranch()) + '` branch.'));
                if (!this.args.dryRun) {
                    await u.gitPush(); // Also pushes any tags.
                }
                if ((await u.isGitRepoOriginGitHub()) && this.args.pkgs && (await u.isNPMPkgPublishable({ mode: this.args.mode }))) {
                    u.log($chalk.green('Generating GitHub release; `v' + u.pkgVersion + '` tag.'));
                    if (!this.args.dryRun) {
                        await u.githubReleaseTag();
                    }
                }
            } else {
                u.log($chalk.gray('Not a git repo.'));
            }
        }

        /**
         * Signals completion with success.
         */

        u.log(await u.finaleBox('Success', 'Project update complete.'));
    }
}

/**
 * Projects command.
 */
class Projects {
    /**
     * Constructor.
     */
    constructor(args) {
        this.args = args;
    }

    /**
     * Runs CMD.
     */
    async run() {
        await this.#update();

        if (this.args.dryRun) {
            u.log($chalk.cyanBright('Dry run. This was all a simulation.'));
        }
    }

    /**
     * Runs update.
     */
    async #update() {
        /**
         * Initializes vars.
         */

        let i; // Initialize.
        const orderedResults = [];
        const hasAllGlob = this.args.globs.includes('*');

        /**
         * Does git ignore setup.
         */

        await this.#doGitIgnoreSetup(); // `.~gitignore` file.

        /**
         * Acquires unordered glob results.
         */

        const unorderedResults = await $glob.promise(this.args.globs, {
            cwd: u.projsDir,
            absolute: false,
            onlyDirectories: true,

            gitignore: true,
            ignoreFiles: ['.~gitignore'],
            ignore: u.projects.updates.ignore.concat(this.args.ignores),
        });

        /**
         * Produces an ordered set of glob results.
         */

        for (const projDirSubpathGlob of u.projects.updates.order.concat(this.args.order)) {
            for (const projDirSubpath of $mm.match(unorderedResults, projDirSubpathGlob)) {
                if (-1 === (i = unorderedResults.indexOf(projDirSubpath))) {
                    continue; // Not applicable.
                }
                orderedResults.push(unorderedResults[i]);
                unorderedResults.splice(i, 1);
            }
        }

        /**
         * Iterates ordered + unordered glob results.
         */

        for await (const projDirSubpath of orderedResults.concat(unorderedResults)) {
            /**
             * Initializes vars.
             */

            const projDir = path.resolve(u.projsDir, projDirSubpath);
            const dfDir = path.resolve(projDir, u.projects.paths.relDfDir);
            const pkgFile = path.resolve(projDir, u.projects.paths.relPkgFile);
            const madrunFile = path.resolve(projDir, u.projects.paths.relMadrunFile);

            const relName = path.basename(u.projsDir) + '/' + projDirSubpath;
            const relDfDir = './' + path.relative(projDir, dfDir);
            const relPkgFile = './' + path.relative(projDir, pkgFile);
            const relMadrunFile = './' + path.relative(projDir, madrunFile);

            /**
             * Validates the current glob result.
             */

            if (hasAllGlob && !fs.existsSync(dfDir)) {
                u.log($chalk.gray('Has glob `*`. No `' + relDfDir + '` in `' + relName + '`. Bypassing.'));
                continue; // Missing important core project directory.
            }
            if (hasAllGlob && !fs.existsSync(pkgFile)) {
                u.log($chalk.gray('Has glob `*`. No `' + relPkgFile + '` in `' + relName + '`. Bypassing.'));
                continue; // Missing important core project file.
            }
            if (hasAllGlob && !fs.existsSync(madrunFile)) {
                u.log($chalk.gray('Has glob `*`. No `' + relMadrunFile + '` in `' + relName + '`. Bypassing.'));
                continue; // Missing important core project file.
            }

            /**
             * Runs CMD(s) for current glob result.
             */

            if (this.args.cmds.length) {
                for (const cmd of this.args.cmds) {
                    for (const cmdArgs of cmd.split(/\s*&&\s*/u)) {
                        const split = $cmd.split(cmdArgs); // Splits into: `{cmd,args}`.

                        const quotedCMD = $cmd.quote(split.cmd); // Used only in output logging.
                        const quotedArgs = $cmd.quoteAll(split.args); // Only in output logging.

                        u.log($chalk.green('Running `' + quotedCMD + (quotedArgs.length ? ' ' + quotedArgs.join(' ') : '') + '` in:') + ' ' + $chalk.yellow(relName));
                        if (!this.args.dryRun) {
                            await u.spawn(split.cmd, split.args, { cwd: projDir, stdio: 'inherit' });
                        }
                    }
                }
            }

            /**
             * Runs script(s) for current glob result.
             */

            if (this.args.runs.length) {
                for (const run of this.args.runs) {
                    for (const cmdArgs of run.split(/\s*&&\s*/u)) {
                        const split = $cmd.split(cmdArgs); // Splits into: `{cmd,args}`.

                        const quotedCMD = $cmd.quote(split.cmd); // Used only in output logging.
                        const quotedArgs = $cmd.quoteAll(split.args); // Only in output logging.

                        u.log($chalk.green('Running `madrun ' + quotedCMD + (quotedArgs.length ? ' ' + quotedArgs.join(' ') : '') + '` in:') + ' ' + $chalk.yellow(relName));
                        if (!this.args.dryRun) {
                            await u.spawn('npx', ['@clevercanyon/madrun', split.cmd, ...split.args], { cwd: projDir, stdio: 'inherit' });
                        }
                    }
                }
            }
        }

        /**
         * Signals completion with success.
         */

        u.log(await u.finaleBox('Success', 'Project updates complete.'));
    }

    /**
     * Does git ignore setup.
     */
    async #doGitIgnoreSetup() {
        if (fs.existsSync(path.resolve(u.projDir, './.gitignore'))) {
            const gitIgnoreFile = path.resolve(u.projsDir, './.~gitignore');
            await fsp.copyFile(path.resolve(u.projDir, './.gitignore'), gitIgnoreFile);
        }
    }
}

/**
 * Yargs ⛵🏴‍☠.
 */
await (async () => {
    await u.propagateUserEnvVars();
    await (
        await $yargs.cli({
            scriptName: 'madrun update',
            version: u.pkgVersion,
        })
    )
        .command({
            command: ['vscode'],
            describe: 'Updates project `./.vscode/settings.json`.',
            builder: (yargs) => {
                return yargs
                    .options({
                        dryRun: {
                            type: 'boolean',
                            requiresArg: false,
                            demandOption: false,
                            default: false,
                            description: 'Dry run?',
                        },
                    })
                    .check(async (/* args */) => {
                        if (!(await u.isInteractive())) {
                            throw new Error('This *must* be performed interactively.');
                        }
                        return true;
                    });
            },
            handler: async (args) => {
                await new VSCode(args).run();
            },
        })
        .command({
            command: ['gitattributes'],
            describe: 'Updates project `./.gitattributes`.',
            builder: (yargs) => {
                return yargs
                    .options({
                        dryRun: {
                            type: 'boolean',
                            requiresArg: false,
                            demandOption: false,
                            default: false,
                            description: 'Dry run?',
                        },
                    })
                    .check(async (/* args */) => {
                        if (!(await u.isInteractive())) {
                            throw new Error('This *must* be performed interactively.');
                        }
                        return true;
                    });
            },
            handler: async (args) => {
                await new GitAttributes(args).run();
            },
        })
        .command({
            command: ['gitignore'],
            describe: 'Updates project `./.gitignore`.',
            builder: (yargs) => {
                return yargs
                    .options({
                        dryRun: {
                            type: 'boolean',
                            requiresArg: false,
                            demandOption: false,
                            default: false,
                            description: 'Dry run?',
                        },
                    })
                    .check(async (/* args */) => {
                        if (!(await u.isInteractive())) {
                            throw new Error('This *must* be performed interactively.');
                        }
                        return true;
                    });
            },
            handler: async (args) => {
                await new GitIgnore(args).run();
            },
        })
        .command({
            command: ['npmignore'],
            describe: 'Updates project `./.npmignore`.',
            builder: (yargs) => {
                return yargs
                    .options({
                        dryRun: {
                            type: 'boolean',
                            requiresArg: false,
                            demandOption: false,
                            default: false,
                            description: 'Dry run?',
                        },
                    })
                    .check(async (/* args */) => {
                        if (!(await u.isInteractive())) {
                            throw new Error('This *must* be performed interactively.');
                        }
                        return true;
                    });
            },
            handler: async (args) => {
                await new NPMIgnore(args).run();
            },
        })
        .command({
            command: ['dockerignore'],
            describe: 'Updates project `./.dockerignore`.',
            builder: (yargs) => {
                return yargs
                    .options({
                        dryRun: {
                            type: 'boolean',
                            requiresArg: false,
                            demandOption: false,
                            default: false,
                            description: 'Dry run?',
                        },
                    })
                    .check(async (/* args */) => {
                        if (!(await u.isInteractive())) {
                            throw new Error('This *must* be performed interactively.');
                        }
                        return true;
                    });
            },
            handler: async (args) => {
                await new DockerIgnore(args).run();
            },
        })
        .command({
            command: ['vscodeignore'],
            describe: 'Updates project `./.vscodeignore`.',
            builder: (yargs) => {
                return yargs
                    .options({
                        dryRun: {
                            type: 'boolean',
                            requiresArg: false,
                            demandOption: false,
                            default: false,
                            description: 'Dry run?',
                        },
                    })
                    .check(async (/* args */) => {
                        if (!(await u.isInteractive())) {
                            throw new Error('This *must* be performed interactively.');
                        }
                        return true;
                    });
            },
            handler: async (args) => {
                await new VSCodeIgnore(args).run();
            },
        })
        .command({
            command: ['prettierignore'],
            describe: 'Updates project `./.prettierignore`.',
            builder: (yargs) => {
                return yargs
                    .options({
                        dryRun: {
                            type: 'boolean',
                            requiresArg: false,
                            demandOption: false,
                            default: false,
                            description: 'Dry run?',
                        },
                    })
                    .check(async (/* args */) => {
                        if (!(await u.isInteractive())) {
                            throw new Error('This *must* be performed interactively.');
                        }
                        return true;
                    });
            },
            handler: async (args) => {
                await new PrettierIgnore(args).run();
            },
        })
        .command({
            command: ['browserslist'],
            describe: 'Updates project `./.browserslistrc`.',
            builder: (yargs) => {
                return yargs
                    .options({
                        dryRun: {
                            type: 'boolean',
                            requiresArg: false,
                            demandOption: false,
                            default: false,
                            description: 'Dry run?',
                        },
                    })
                    .check(async (/* args */) => {
                        if (!(await u.isInteractive())) {
                            throw new Error('This *must* be performed interactively.');
                        }
                        return true;
                    });
            },
            handler: async (args) => {
                await new Browserslist(args).run();
            },
        })
        .command({
            command: ['tsconfig'],
            describe: 'Updates project `./tsconfig.json`.',
            builder: (yargs) => {
                return yargs
                    .options({
                        dryRun: {
                            type: 'boolean',
                            requiresArg: false,
                            demandOption: false,
                            default: false,
                            description: 'Dry run?',
                        },
                    })
                    .check(async (/* args */) => {
                        if (!(await u.isInteractive())) {
                            throw new Error('This *must* be performed interactively.');
                        }
                        return true;
                    });
            },
            handler: async (args) => {
                await new TSConfig(args).run();
            },
        })
        .command({
            command: ['wrangler'],
            describe: 'Updates project `./wrangler.toml`.',
            builder: (yargs) => {
                return yargs
                    .options({
                        dryRun: {
                            type: 'boolean',
                            requiresArg: false,
                            demandOption: false,
                            default: false,
                            description: 'Dry run?',
                        },
                    })
                    .check(async (/* args */) => {
                        if (!(await u.isInteractive())) {
                            throw new Error('This *must* be performed interactively.');
                        }
                        return true;
                    });
            },
            handler: async (args) => {
                await new Wrangler(args).run();
            },
        })
        .command({
            command: ['dotfiles'],
            describe: 'Updates project dotfiles.',
            builder: (yargs) => {
                return yargs
                    .options({
                        message: {
                            alias: 'm',
                            type: 'string',
                            requiresArg: true,
                            demandOption: false,
                            default: 'Dotfiles update.',
                            description: 'Commit message when updating `clevercanyon/skeleton`.',
                        },
                        dryRun: {
                            type: 'boolean',
                            requiresArg: false,
                            demandOption: false,
                            default: false,
                            description: 'Dry run?',
                        },
                    })
                    .check(async (/* args */) => {
                        if (!(await u.isInteractive())) {
                            throw new Error('This *must* be performed interactively.');
                        }
                        return true;
                    });
            },
            handler: async (args) => {
                await new Dotfiles(args).run();
            },
        })
        .command({
            command: ['project'],
            describe: 'Updates NPM packages + optionally pushes to repo(s) + optionally publishes package(s).',
            builder: (yargs) => {
                return yargs
                    .options({
                        repos: {
                            type: 'boolean',
                            requiresArg: false,
                            demandOption: false,
                            default: false,
                            description: 'Push to project repo(s)?',
                            alias: ['repo'],
                        },
                        message: {
                            alias: 'm',
                            type: 'string',
                            requiresArg: true,
                            demandOption: false,
                            default: 'Project update.',
                            implies: ['repos'],
                            description: 'Commit message when updating repos.',
                        },
                        pkgs: {
                            type: 'boolean',
                            requiresArg: false,
                            demandOption: false,
                            default: false,
                            implies: ['repos'],
                            description: 'Publish updated project package(s)?',
                            alias: ['pkg'],
                        },
                        npm: {
                            type: 'string',
                            requiresArg: true,
                            demandOption: false,
                            default: 'default',
                            choices: ['nimble', 'no', 'default'],
                            description: // prettier-ignore
                                'When set as `nimble`, the updater first does a normal NPM update of your project’s own `dependencies` and `peerDependencies`.' +
                                ' Also, it updates all `@clevercanyon/*` dependencies used by `@clevercanyon/dev-deps` for local project development.' +
                                ' Then it does a full update in `--prefer-offline` mode, which is quite effective at optimizing for speedy updates.' +
                                ' Or, when set as `no`, NPM updates are skipped entirely, which is strongly recommended when updating `--repos --pkgs`.' +
                                ' Or, when set as `default`, the updater simply does a normal NPM update with no speed optimizations.',
                        },
                        mode: {
                            type: 'string',
                            requiresArg: true,
                            demandOption: false,
                            default: 'prod',
                            choices: ['dev', 'ci', 'stage', 'prod'],
                            description: 'Build and env mode.',
                        },
                        dryRun: {
                            type: 'boolean',
                            requiresArg: false,
                            demandOption: false,
                            default: false,
                            description: 'Dry run?',
                        },
                    })
                    .check(async (/* args */) => {
                        if (!(await u.isInteractive())) {
                            throw new Error('This *must* be performed interactively.');
                        }
                        return true;
                    });
            },
            handler: async (args) => {
                await new Project(args).run();
            },
        })
        .command({
            command: ['projects'],
            describe: 'Updates multiple projects.',
            builder: (yargs) => {
                return yargs
                    .options({
                        globs: {
                            type: 'array',
                            requiresArg: true,
                            demandOption: false,
                            default: ['*', '.github'],
                            description:  // prettier-ignore
								'Glob matching is relative to `' + u.projsDir + '` and finds directories only.' +
								' Note: Globstars `**` are not allowed given the nature of this command and will therefore throw an error.' +
								' Please be more specific. Wildcards `*` are fine, but globstars `**` are prohibited in this option.',
                            alias: ['globs[]', 'globs[', 'glob', 'glob[]', 'glob['],
                        },
                        ignores: {
                            type: 'array',
                            requiresArg: true,
                            demandOption: false,
                            default: u.projects.updates.ignore,
                            description: // prettier-ignore
								'Glob matching is relative to `' + u.projsDir + '`. This effectively excludes directories otherwise found by the `glob` option.' +
								' Note: The default ignore patterns are always in effect and cannot be overridden, only appended with this option.' +
								' Additionally, patterns in this project’s `.gitignore` file, and those within each matched project directory, are also always in effect.',
                            alias: ['ignores[]', 'ignores[', 'ignore', 'ignore[]', 'ignore['],
                        },
                        order: {
                            type: 'array',
                            requiresArg: true,
                            demandOption: false,
                            default: u.projects.updates.order,
                            description: // prettier-ignore
								'Project subpaths to prioritize, in order. Also, globbing is supported in this option, for loose ordering.' +
								' Note: It’s not necessary to list every single project directory, only those you need to prioritize, in a specific order.' +
								' Any that are not listed explicitly, in order, will run last, in an arbitrary glob-based ordering, which is generally unpredictable.' +
								' Note: The default ordering is always in effect and cannot be overridden, only appended with this option.',
                            alias: ['order[]', 'order['],
                        },
                        cmds: {
                            type: 'array',
                            requiresArg: true,
                            demandOption: false,
                            default: [],
                            description: // prettier-ignore
								'Arbitrary `[cmd] [args]` to run in each project directory.' +
								' Note: The use of `&&` is allowed, but the use of `||` or `|` pipes is not permitted at this time.' +
								' If both `cmd` and `run` are given, `cmd` will always run first.',
                            alias: ['cmds[]', 'cmds[', 'cmd', 'cmd[]', 'cmd['],
                        },
                        runs: {
                            type: 'array',
                            requiresArg: true,
                            demandOption: false,
                            default: [],
                            description: // prettier-ignore
								'Scripts to `madrun [cmd] [args]` in each project directory.' +
								' Note: The use of `&&` is allowed, but the use of `||` or `|` pipes is not permitted at this time.' +
								' If both `cmd` and `run` are given, `cmd` will always run first.',
                            alias: ['runs[]', 'runs[', 'run', 'run[]', 'run['],
                        },
                        dryRun: {
                            type: 'boolean',
                            requiresArg: false,
                            demandOption: false,
                            default: false,
                            description: 'Dry run?',
                        },
                    })
                    .check(async (args) => {
                        if (!args.globs.length) {
                            throw new Error('Empty `glob` option.');
                        }
                        if (args.globs.includes('**') || $mm.match(args.globs, ['\\*\\*'], { contains: true }).length) {
                            throw new Error('Globstars `**` are prohitibed in `glob` option.');
                        }
                        if (!args.cmds.length && !args.runs.length) {
                            throw new Error('One of `cmd` and/or `run` is required.');
                        }
                        if (!(await u.isInteractive())) {
                            throw new Error('This *must* be performed interactively.');
                        }
                        return true;
                    });
            },
            handler: async (args) => {
                await new Projects(args).run();
            },
        })
        .parse();
})();
