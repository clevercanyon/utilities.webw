#!/usr/bin/env node
/**
 * Env CLI.
 *
 * @note PLEASE DO NOT EDIT THIS FILE!
 * @note This entire file will be updated automatically.
 * @note Instead of editing here, please review <https://github.com/clevercanyon/skeleton>.
 */
/* eslint-env es2021, node */

import fs from 'node:fs';
import path from 'node:path';
import fsp from 'node:fs/promises';

import desm from 'desm';
import chalk from 'chalk';
import spawn from 'spawn-please';

import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';

const __dirname = desm(import.meta.url);
const projDir = path.resolve(__dirname, '../../..');

const { log } = console;
const echo = process.stdout.write.bind(process.stdout);

const noisySpawnCfg = {
	cwd: projDir, // Displays output while running.
	stdout: (buffer) => echo(chalk.blue(buffer.toString())),
	stderr: (buffer) => echo(chalk.redBright(buffer.toString())),
};
const envFiles = {
	main: path.resolve(projDir, './dev/.envs/.env'),
	dev: path.resolve(projDir, './dev/.envs/.env.dev'),
	ci: path.resolve(projDir, './dev/.envs/.env.ci'),
	stage: path.resolve(projDir, './dev/.envs/.env.stage'),
	prod: path.resolve(projDir, './dev/.envs/.env.prod'),
};

/**
 * Setup command.
 */
class Setup {
	constructor(args) {
		this.args = args;

		(async () => {
			if (this.args['new']) {
				await this.setupNew();
			} else {
				await this.setup();
			}
			if (this.args.dryRun) {
				log(chalk.cyanBright('Dry run. This was all a simulation.'));
			}
		})();
	}

	async setupNew() {
		log(chalk.green('Setting up new envs.'));

		log(chalk.gray('Deleting `.env.me`, `.env.vault`.'));
		if (!this.args.dryRun) {
			await fsp.rm(path.resolve(projDir, './.env.me'), { force: true });
			await fsp.rm(path.resolve(projDir, './.env.vault'), { force: true });
		}
		log(chalk.gray('Running `dotenv-vault new`, `login`, `open`.'));
		if (!this.args.dryRun) {
			await spawn('npx', ['dotenv-vault', 'new', '--yes'], noisySpawnCfg);
			await spawn('npx', ['dotenv-vault', 'login', '--yes'], noisySpawnCfg);
			await spawn('npx', ['dotenv-vault', 'open', '--yes'], noisySpawnCfg);
		}
		log(chalk.gray('Pushing envs.'));
		await Utilities.push({ dryRun: this.args.dryRun });

		log(chalk.gray('Building envs.'));
		await Utilities.build({ dryRun: this.args.dryRun });
	}

	async setup() {
		log(chalk.green('Setting up envs.'));

		log(chalk.gray('Running `dotenv-vault login`, `open`.'));
		if (!this.args.dryRun) {
			await spawn('npx', ['dotenv-vault', 'login', '--yes'], noisySpawnCfg);
			await spawn('npx', ['dotenv-vault', 'open', '--yes'], noisySpawnCfg);
		}
		log(chalk.gray('Pulling envs.'));
		await Utilities.pull({ dryRun: this.args.dryRun });
	}
}

/**
 * Push command.
 */
class Push {
	constructor(args) {
		this.args = args;

		(async () => {
			log(chalk.green('Pushing envs.'));
			await Utilities.push({ dryRun: this.args.dryRun });

			if (this.args.dryRun) {
				log(chalk.cyanBright('Dry run. This was all a simulation.'));
			}
		})();
	}
}

/**
 * Pull command.
 */
class Pull {
	constructor(args) {
		this.args = args;

		(async () => {
			log(chalk.green('Pulling envs.'));
			await Utilities.pull({ dryRun: this.args.dryRun });

			if (this.args.dryRun) {
				log(chalk.cyanBright('Dry run. This was all a simulation.'));
			}
		})();
	}
}

/**
 * Build command.
 */
class Build {
	constructor(args) {
		this.args = args;

		(async () => {
			log(chalk.green('Building envs.'));
			await Utilities.build({ dryRun: this.args.dryRun });

			if (this.args.dryRun) {
				log(chalk.cyanBright('Dry run. This was all a simulation.'));
			}
		})();
	}
}

/**
 * Misc. utilities.
 */
class Utilities {
	static async push(opts = { dryRun: false }) {
		for (const [envName, envFile] of Object.entries(envFiles)) {
			if (!fs.existsSync(envFile)) {
				log(chalk.gray('Creating file for `' + envName + '` env.'));
				if (!opts.dryRun) {
					await fsp.mkdir(path.dirname(envFile), { recursive: true });
					await fsp.writeFile(envFile, '# ' + envName);
				}
			}
			log(chalk.gray('Running `dotenv-vault push` for `' + envName + '` env.'));
			if (!opts.dryRun) {
				await spawn('npx', ['dotenv-vault', 'push', envName, envFile, '--yes'], noisySpawnCfg);
			}
		}
	}

	static async pull(opts = { dryRun: false }) {
		for (const [envName, envFile] of Object.entries(envFiles)) {
			log(chalk.gray('Running `dotenv-vault pull` for `' + envName + '` env.'));
			if (!opts.dryRun) {
				await fsp.mkdir(path.dirname(envFile), { recursive: true });
				await spawn('npx', ['dotenv-vault', 'pull', envName, envFile, '--yes'], noisySpawnCfg);
			}
			log(chalk.gray('Deleting previous file for `' + envName + '` env.'));
			if (!opts.dryRun) {
				await fsp.rm(envFile + '.previous', { force: true });
			}
		}
	}

	static async build(opts = { dryRun: false }) {
		log(chalk.gray('Running `dotenv-vault build`.'));
		if (!opts.dryRun) {
			await spawn('npx', ['dotenv-vault', 'build', '--yes'], noisySpawnCfg);
		}
	}
}

/**
 * Yargs ⛵🏴‍☠
 *
 * @see http://yargs.js.org/docs/
 */
(async () => {
	await yargs(hideBin(process.argv))
		.command(
			'setup',
			'Sets up dotenv vault.',
			{
				'new': {
					type: 'boolean',
					requiresArg: false,
					demandOption: false,
					default: false,
					description: 'Set up *new* envs?',
				},
				dryRun: {
					type: 'boolean',
					requiresArg: false,
					demandOption: false,
					default: false,
					description: 'Dry run?',
				},
			},
			(args) => new Setup(args),
		)
		.command(
			'push',
			'Pushes to dotenv vault.',
			{
				dryRun: {
					type: 'boolean',
					requiresArg: false,
					demandOption: false,
					default: false,
					description: 'Dry run?',
				},
			},
			(args) => new Push(args),
		)
		.command(
			'pull',
			'Pulls from dotenv vault.',
			{
				dryRun: {
					type: 'boolean',
					requiresArg: false,
					demandOption: false,
					default: false,
					description: 'Dry run?',
				},
			},
			(args) => new Pull(args),
		)
		.command(
			'build',
			'Builds dotenv vault.',
			{
				dryRun: {
					type: 'boolean',
					requiresArg: false,
					demandOption: false,
					default: false,
					description: 'Dry run?',
				},
			},
			(args) => new Build(args),
		)
		.strict()
		.help()
		.parse();
})();
