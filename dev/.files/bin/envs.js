#!/usr/bin/env node
/**
 * Env CLI.
 *
 * @note PLEASE DO NOT EDIT THIS FILE!
 * @note This entire file will be updated automatically.
 * @note Instead of editing here, please review <https://github.com/clevercanyon/skeleton>.
 */
/* eslint-env es2021, node */

import fs from 'node:fs';
import path from 'node:path';
import { dirname } from 'desm';
import fsp from 'node:fs/promises';

import coloredBox from 'boxen';
import chalk, { supportsColor } from 'chalk';

import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';

import spawn from 'spawn-please';
import dotenvVaultCore from 'dotenv-vault-core';

const __dirname = dirname(import.meta.url);
const projDir = path.resolve(__dirname, '../../..');

const { log } = console;
const echo = process.stdout.write.bind(process.stdout);

const isParentTTY = process.stdout.isTTY ? true : false;
const isTTY = process.stdout.isTTY || process.env.PARENT_IS_TTY ? true : false;

const noisySpawnCfg = {
	cwd: projDir,
	env: { ...process.env, PARENT_IS_TTY: isTTY },
	stdout: (buffer) => echo(chalk.blue(buffer.toString())),
	stderr: (buffer) => echo(chalk.redBright(buffer.toString())),
};
const envFiles = {
	main: path.resolve(projDir, './dev/.envs/.env'),
	dev: path.resolve(projDir, './dev/.envs/.env.dev'),
	ci: path.resolve(projDir, './dev/.envs/.env.ci'),
	stage: path.resolve(projDir, './dev/.envs/.env.stage'),
	prod: path.resolve(projDir, './dev/.envs/.env.prod'),
};
const c10nEmoji = '🦊'; // Clever Canyon’s adopted emoji icon.

/**
 * NOTE: Most of these commands _must_ be performed interactively. Please eview the Yargs configuration below for
 * further details. At this time, only the `decrypt` command is allowed noninteractively, and _only_ noninteractively.
 */

/**
 * Setup command.
 */
class Setup {
	constructor(args) {
		this.args = args;
	}

	async run() {
		if (this.args['new']) {
			await this.setupNew();
		} else {
			await this.setup();
		}
		if (this.args.dryRun) {
			log(chalk.cyanBright('Dry run. This was all a simulation.'));
		}
	}

	async setupNew() {
		log(chalk.green('Setting up all new envs.'));

		log(chalk.gray('Deleting `.env.me`, `.env.vault`.'));
		if (!this.args.dryRun) {
			await fsp.rm(path.resolve(projDir, './.env.me'), { force: true });
			await fsp.rm(path.resolve(projDir, './.env.vault'), { force: true });
		}
		log(chalk.gray('Running `dotenv-vault new`, `login`, `open`.'));
		if (!this.args.dryRun) {
			await spawn('npx', ['dotenv-vault', 'new', '--yes'], noisySpawnCfg);
			await spawn('npx', ['dotenv-vault', 'login', '--yes'], noisySpawnCfg);
			await spawn('npx', ['dotenv-vault', 'open', '--yes'], noisySpawnCfg);
		}
		log(chalk.gray('Pushing all envs.'));
		await u.push({ dryRun: this.args.dryRun });

		log(chalk.gray('Encrypting all envs.'));
		await u.encrypt({ dryRun: this.args.dryRun });

		log(u.finale('Success', 'New setup complete.'));
	}

	async setup() {
		log(chalk.green('Setting up all envs.'));

		if (!fs.existsSync(path.resolve(projDir, './.env.me'))) {
			log(chalk.gray('Running `dotenv-vault login`, `open`.'));
			if (!this.args.dryRun) {
				await spawn('npx', ['dotenv-vault', 'login', '--yes'], noisySpawnCfg);
				await spawn('npx', ['dotenv-vault', 'open', '--yes'], noisySpawnCfg);
			}
		}
		if (this.args.pull || !fs.existsSync(envFiles.main)) {
			log(chalk.gray('Pulling all envs.'));
			await u.pull({ dryRun: this.args.dryRun });
		}
		log(u.finale('Success', 'Setup complete.'));
	}
}

/**
 * Push command.
 */
class Push {
	constructor(args) {
		this.args = args;
	}

	async run() {
		log(chalk.green('Pushing all envs.'));
		await u.push({ dryRun: this.args.dryRun });

		log(u.finale('Success', 'Push complete.'));

		if (this.args.dryRun) {
			log(chalk.cyanBright('Dry run. This was all a simulation.'));
		}
	}
}

/**
 * Pull command.
 */
class Pull {
	constructor(args) {
		this.args = args;
	}

	async run() {
		log(chalk.green('Pulling all envs.'));
		await u.pull({ dryRun: this.args.dryRun });

		log(u.finale('Success', 'Pull complete.'));

		if (this.args.dryRun) {
			log(chalk.cyanBright('Dry run. This was all a simulation.'));
		}
	}
}

/**
 * Keys command.
 */
class Keys {
	constructor(args) {
		this.args = args;
	}

	async run() {
		log(chalk.green('Retrieving keys for all envs.'));
		await u.keys({ dryRun: this.args.dryRun });

		log(u.finale('Success', '↑ Here they are.'));

		if (this.args.dryRun) {
			log(chalk.cyanBright('Dry run. This was all a simulation.'));
		}
	}
}

/**
 * Encrypt command.
 */
class Encrypt {
	constructor(args) {
		this.args = args;
	}

	async run() {
		log(chalk.green('Encrypting all envs.'));
		await u.encrypt({ dryRun: this.args.dryRun });

		log(u.finale('Success', 'Encryption complete.'));

		if (this.args.dryRun) {
			log(chalk.cyanBright('Dry run. This was all a simulation.'));
		}
	}
}

/**
 * Decrypt command.
 */
class Decrypt {
	constructor(args) {
		this.args = args;
	}

	async run() {
		log(chalk.green('Decrypting env(s).'));
		await u.decrypt({ keys: this.args.keys, dryRun: this.args.dryRun });

		log(u.finale('Success', 'Decryption complete.'));

		if (this.args.dryRun) {
			log(chalk.cyanBright('Dry run. This was all a simulation.'));
		}
	}
}

/**
 * Utilities.
 */
class u {
	/*
	 * TTY utilities.
	 */

	static async isInteractive() {
		return isTTY && process.env.TERM && 'dumb' !== process.env.TERM && 'true' !== process.env.CI;
	}

	/*
	 * Push utilities.
	 */

	static async push(opts = { dryRun: false }) {
		for (const [envName, envFile] of Object.entries(envFiles)) {
			if (!fs.existsSync(envFile)) {
				log(chalk.gray('Creating file for `' + envName + '` env.'));
				if (!opts.dryRun) {
					await fsp.mkdir(path.dirname(envFile), { recursive: true });
					await fsp.writeFile(envFile, '# ' + envName);
				}
			}
			log(chalk.gray('Running `dotenv-vault push` for `' + envName + '` env.'));
			if (!opts.dryRun) {
				await spawn('npx', ['dotenv-vault', 'push', envName, envFile, '--yes'], noisySpawnCfg);
			}
		}
	}

	/*
	 * Pull utilities.
	 */

	static async pull(opts = { dryRun: false }) {
		for (const [envName, envFile] of Object.entries(envFiles)) {
			log(chalk.gray('Running `dotenv-vault pull` for `' + envName + '` env.'));
			if (!opts.dryRun) {
				await fsp.mkdir(path.dirname(envFile), { recursive: true });
				await spawn('npx', ['dotenv-vault', 'pull', envName, envFile, '--yes'], noisySpawnCfg);
			}
			log(chalk.gray('Deleting previous file for `' + envName + '` env.'));
			if (!opts.dryRun) {
				await fsp.rm(envFile + '.previous', { force: true });
			}
		}
	}

	/*
	 * Keys utilities.
	 */

	static async keys(opts = { dryRun: false }) {
		log(chalk.gray('Running `dotenv-vault keys`.'));
		if (!opts.dryRun) {
			await spawn('npx', ['dotenv-vault', 'keys', '--yes'], noisySpawnCfg);
		}
	}

	/*
	 * Encryption utilities.
	 */

	static async encrypt(opts = { dryRun: false }) {
		log(chalk.gray('Running `dotenv-vault build`.'));
		if (!opts.dryRun) {
			await spawn('npx', ['dotenv-vault', 'build', '--yes'], noisySpawnCfg);
		}
	}

	static async decrypt(opts = { keys: [], dryRun: false }) {
		for (const key of opts.keys) {
			const envName = key.split('?')[1]?.split('=')[1] || '';
			const envFile = envFiles[envName] || '';

			if (!envName || !envFile) {
				throw new Error('Invalid key: `' + key + '`.');
			}
			log(chalk.gray('Decrypting `' + envName + '` env.'));
			if (!opts.dryRun) {
				const origDotenvKey = process.env.DOTENV_KEY || '';
				process.env.DOTENV_KEY = key; // For `dotEnvVaultCore`.

				// Note: `path` leads to `.env.vault`. See: <https://o5p.me/MqXJaf>.
				const env = dotenvVaultCore.config({ path: path.resolve(projDir, './.env' /* .vault */) });

				await fsp.writeFile(envFile, await u.toString(envName, env));
				process.env.DOTENV_KEY = origDotenvKey;
			}
		}
	}

	static async toString(envName, env) {
		let str = '# ' + envName + '\n';

		for (let [name, value] of Object.entries(env)) {
			value = value.replace(/\r\n?/gu, '\n');
			value = value.replace(/\n/gu, '\\n');
			str += name + '="' + value.replace(/"/gu, '\\"') + '"\n';
		}
		return str;
	}

	/*
	 * NPM utilities.
	 */

	static async npmLifecycleEvent() {
		return process.env.npm_lifecycle_event || ''; // NPM script name.
	}

	static async npmLifecycleScript() {
		return process.env.npm_lifecycle_script || ''; // NPM script value.
	}

	/**
	 * Error utilities.
	 */
	static async error(title, text) {
		if (!isParentTTY || !supportsColor?.has16m) {
			return chalk.red(text); // No box.
		}
		return coloredBox(chalk.red(text), {
			margin: 0,
			padding: 0.75,
			textAlignment: 'left',

			dimBorder: false,
			borderStyle: 'round',
			borderColor: '#551819',
			backgroundColor: '',

			titleAlignment: 'left',
			title: '🙈 ' + chalk.redBright('✖ ' + title),
		});
	}

	/**
	 * Finale utilities.
	 */
	static async finale(title, text) {
		if (!isParentTTY || !supportsColor?.has16m) {
			return chalk.green(text); // No box.
		}
		return coloredBox(chalk.green(text), {
			margin: 0,
			padding: 0.75,
			textAlignment: 'left',

			dimBorder: false,
			borderStyle: 'round',
			borderColor: '#445d2c',
			backgroundColor: '',

			titleAlignment: 'left',
			title: c10nEmoji + ' ' + chalk.greenBright('✓ ' + title),
		});
	}
}

/**
 * Yargs ⛵🏴‍☠
 *
 * @see http://yargs.js.org/docs/
 */
(async () => {
	await yargs(hideBin(process.argv))
		.command({
			command: 'setup',
			desc: 'Sets up all envs for dotenv vault.',
			builder: (yargs) => {
				yargs
					.options({
						'new': {
							type: 'boolean',
							requiresArg: false,
							demandOption: false,
							default: false,
							description: 'Set up *new* envs?',
						},
						pull: {
							type: 'boolean',
							requiresArg: false,
							demandOption: false,
							default: false,
							description: // prettier-ignore
								'When not `--new`, pull latest envs from dotenv vault?' +
								' If not set explicitly, only pulls when main env is missing.' +
								' Note: This option has no effect when `--new`.',
						},
						dryRun: {
							type: 'boolean',
							requiresArg: false,
							demandOption: false,
							default: false,
							description: 'Dry run?',
						},
					})
					.check(async (/* args */) => {
						if (!(await u.isInteractive())) {
							throw new Error('This *must* be performed interactively.');
						}
						return true;
					});
			},
			handler: async (args) => {
				await new Setup(args).run();
			},
		})
		.command({
			command: 'push',
			desc: 'Pushes all envs to dotenv vault.',
			builder: (yargs) => {
				yargs
					.options({
						dryRun: {
							type: 'boolean',
							requiresArg: false,
							demandOption: false,
							default: false,
							description: 'Dry run?',
						},
					})
					.check(async (/* args */) => {
						if (!(await u.isInteractive())) {
							throw new Error('This *must* be performed interactively.');
						}
						return true;
					});
			},
			handler: async (args) => {
				await new Push(args).run();
			},
		})
		.command({
			command: 'pull',
			desc: 'Pulls all envs from dotenv vault.',
			builder: (yargs) => {
				yargs
					.options({
						dryRun: {
							type: 'boolean',
							requiresArg: false,
							demandOption: false,
							default: false,
							description: 'Dry run?',
						},
					})
					.check(async (/* args */) => {
						if (!(await u.isInteractive())) {
							throw new Error('This *must* be performed interactively.');
						}
						return true;
					});
			},
			handler: async (args) => {
				await new Pull(args).run();
			},
		})
		.command({
			command: 'keys',
			desc: 'Retrieves decryption keys for all envs.',
			builder: (yargs) => {
				yargs
					.options({
						dryRun: {
							type: 'boolean',
							requiresArg: false,
							demandOption: false,
							default: false,
							description: 'Dry run?',
						},
					})
					.check(async (/* args */) => {
						if (!(await u.isInteractive())) {
							throw new Error('This *must* be performed interactively.');
						}
						return true;
					});
			},
			handler: async (args) => {
				await new Keys(args).run();
			},
		})
		.command({
			command: 'encrypt',
			desc: 'Encrypts all envs into `.env.vault`.',
			builder: (yargs) => {
				yargs
					.options({
						dryRun: {
							type: 'boolean',
							requiresArg: false,
							demandOption: false,
							default: false,
							description: 'Dry run?',
						},
					})
					.check(async (/* args */) => {
						if (!(await u.isInteractive())) {
							throw new Error('This *must* be performed interactively.');
						}
						return true;
					});
			},
			handler: async (args) => {
				await new Encrypt(args).run();
			},
		})
		.command({
			command: 'decrypt',
			desc: 'Decrypts `.env.vault` env(s) for the given key(s).',
			builder: (yargs) => {
				yargs
					.options({
						keys: {
							type: 'array',
							requiresArg: true,
							demandOption: true,
							default: [],
							description: 'To decrypt `.env.vault` env(s).',
						},
						dryRun: {
							type: 'boolean',
							requiresArg: false,
							demandOption: false,
							default: false,
							description: 'Dry run?',
						},
					})
					.check(async (/* args */) => {
						if (await u.isInteractive()) {
							throw new Error('This can *only* be performed noninteractively.');
						}
						return true;
					});
			},
			handler: async (args) => {
				await new Decrypt(args).run();
			},
		})
		.fail(async (message, error /* , yargs */) => {
			if (error.stack && typeof error.stack === 'string') log(chalk.gray(error.stack));
			log(await u.error('Failure', error ? error.toString() : message));
			process.exit(1);
		})
		.strict()
		.parse();
})();
