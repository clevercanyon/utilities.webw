/**
 * Dotfiles updater.
 *
 * @note PLEASE DO NOT EDIT THIS FILE!
 * @note This entire file will be updated automatically.
 * @note Instead of editing here, please review <https://github.com/clevercanyon/skeleton>.
 */

import fs from 'node:fs';
import fsp from 'node:fs/promises';
import path from 'node:path';
import { $chalk, $fs, $prettier } from '../../../../node_modules/@clevercanyon/utilities.node/dist/index.js';
import { $is, $json, $obj, $obp, $str } from '../../../../node_modules/@clevercanyon/utilities/dist/index.js';
import nodeVersion from '../includes/node-version.mjs';
import customRegExp from './data/custom-regexp.mjs';

export default async ({ projDir }) => {
    /**
     * Initializes vars.
     */
    const { log } = console;
    const __dirname = $fs.imuDirname(import.meta.url);
    const skeletonDir = path.resolve(__dirname, '../../../..');

    /**
     * Gets current `./package.json`.
     *
     * @returns {object} Parsed `./package.json`.
     */
    const getPkg = async () => {
        const pkgFile = path.resolve(projDir, './package.json');

        if (!fs.existsSync(pkgFile)) {
            throw new Error('updater.getPkg: Missing `./package.json`.');
        }
        const pkg = $json.parse(fs.readFileSync(pkgFile).toString());

        if (!$is.plainObject(pkg)) {
            throw new Error('updater.getPkg: Unable to parse `./package.json`.');
        }
        return pkg;
    };

    /**
     * Gets properties from `./package.json` file.
     */
    const { pkgRepository, pkgDotfileLocks } = await (async () => {
        const pkg = await getPkg();
        const pkgRepository = pkg.repository || '';

        let pkgDotfileLocks = $obp.get(pkg, 'config.c10n.&.dotfiles.lock', []);
        pkgDotfileLocks = pkgDotfileLocks.map((relPath) => path.resolve(projDir, relPath));

        return { pkgRepository, pkgDotfileLocks };
    })();

    /**
     * Tests `pkgRepository` against an `owner/repo` string.
     *
     * @param   {string}  ownerRepo An `owner/repo` string.
     *
     * @returns {boolean}           True if current package repo is `ownerRepo`.
     */
    const isPkgRepo = async (ownerRepo) => {
        return new RegExp('[:/]' + $str.escRegExp(ownerRepo) + '(?:\\.git)?$', 'iu').test(pkgRepository);
    };

    /**
     * Checks dotfile locks.
     *
     * @param   {string}  relPath Relative dotfile path.
     *
     * @returns {boolean}         True if relative path is locked by `./package.json`.
     */
    const isLocked = async (relPath) => {
        // Compares absolute paths to each other.
        const absPath = path.resolve(projDir, relPath);

        for (let i = 0; i < pkgDotfileLocks.length; i++) {
            if (absPath === pkgDotfileLocks[i]) {
                return true; // Locked ðŸ”’.
            }
        }
        return false;
    };

    /**
     * Deletes outdated dotfiles no longer in use.
     */
    for (const relPath of [
        './dev/.envs/.~comp', //
        './.vscode/mdx-layout.mjsx',
        './.madrun.mjs',
        './ts-types.d.ts',
        './tsconfig.d.ts',
    ]) {
        if (await isLocked(relPath)) {
            continue; // Locked ðŸ”’.
        }
        await fsp.rm(path.resolve(projDir, relPath), { recursive: true, force: true });
    }

    /**
     * Updates immutable directories.
     */
    for (const relPath of ['./dev/.files']) {
        await fsp.rm(path.resolve(projDir, relPath), { recursive: true, force: true });
        await fsp.mkdir(path.resolve(projDir, relPath), { recursive: true });
        await fsp.cp(path.resolve(skeletonDir, relPath), path.resolve(projDir, relPath), { recursive: true });
    }
    await fsp.chmod(path.resolve(projDir, './dev/.files/bin/envs.mjs'), 0o700);
    await fsp.chmod(path.resolve(projDir, './dev/.files/bin/install.mjs'), 0o700);
    await fsp.chmod(path.resolve(projDir, './dev/.files/bin/update.mjs'), 0o700);

    /**
     * Updates semi-immutable dotfiles.
     */
    for (const relPath of [
        './.npmrc',
        './.npmignore',

        './.gitignore',
        './.gitattributes',

        './.github/CODEOWNERS',
        './.github/dependabot.yml',
        './.github/workflows/ci.yml',

        './.editorconfig',
        './.vscodeignore',
        './.vscode/extensions.json',
        './.vscode/settings.json',
        './.vscode/settings.mjs',

        './eslint.config.mjs',
        './stylelint.config.mjs',
        './postcss.config.mjs',
        './tailwind.config.mjs',

        './prettier.config.mjs',
        './.prettierignore',

        './.dockerignore',
        './.shellcheckrc',
        './.browserslistrc',

        './.remarkrc.mjs',
        './.rehyperc.mjs',
        './mdx.config.mjs',

        './dev-types.d.ts',
        './tsconfig.json',
        './tsconfig.mjs',

        './jest.config.mjs',
        './vite.config.mjs',

        './wrangler.toml',
        './wrangler.mjs',

        './madrun.config.mjs',
    ]) {
        if (await isLocked(relPath)) {
            continue; // Locked ðŸ”’.
        }
        let newFileContents = ''; // Initialize.

        if (fs.existsSync(path.resolve(projDir, relPath))) {
            const oldFileContents = (await fsp.readFile(path.resolve(projDir, relPath))).toString();
            const oldFileMatches = customRegExp.exec(oldFileContents); // See: `./data/custom-regexp.js`.
            const oldFileCustomCode = oldFileMatches ? oldFileMatches[2] : ''; // We'll preserve any custom code.
            newFileContents = (await fsp.readFile(path.resolve(skeletonDir, relPath))).toString().replace(customRegExp, ($_, $1, $2, $3) => $1 + oldFileCustomCode + $3);
        } else {
            newFileContents = (await fsp.readFile(path.resolve(skeletonDir, relPath))).toString();
        }
        await fsp.mkdir(path.dirname(path.resolve(projDir, relPath)), { recursive: true });
        await fsp.writeFile(path.resolve(projDir, relPath), newFileContents);
    }

    /**
     * Adds up-to-date copies of missing mutable files.
     */
    for (const relPath of [
        './LICENSE.txt', //
        './README.md',
    ]) {
        if (await isLocked(relPath)) {
            continue; // Locked ðŸ”’.
        }
        if (!fs.existsSync(path.resolve(projDir, relPath))) {
            await fsp.cp(path.resolve(skeletonDir, relPath), path.resolve(projDir, relPath));
        }
    }

    /**
     * Adds and/or updates updateable JSON files.
     */
    for (const relPath of [
        './package.json', //
    ]) {
        if (await isLocked(relPath)) {
            continue; // Locked ðŸ”’.
        }
        if (!fs.existsSync(path.resolve(projDir, relPath))) {
            await fsp.cp(path.resolve(skeletonDir, relPath), path.resolve(projDir, relPath));
        }
        let json = $json.parse((await fsp.readFile(path.resolve(projDir, relPath))).toString());
        const updatesRelPath = relPath.replace(/(^|\/)([^/]+\.[^.]+)$/u, '$1_$2'); // Leading underscore in basename.
        const updatesFile = path.resolve(skeletonDir, './dev/.files/bin/updater/data', updatesRelPath, './updates.json');

        if (!$is.plainObject(json)) {
            throw new Error('updater: Unable to parse `' + relPath + '`.');
        }
        if (fs.existsSync(updatesFile)) {
            const updates = $json.parse((await fsp.readFile(updatesFile)).toString());

            if (!$is.plainObject(updates)) {
                throw new Error('updater: Unable to parse `' + updatesFile + '`.');
            }
            if ('./package.json' === relPath) {
                if (Object.hasOwn(updates.$ê“ºset?.engines || {}, 'node')) {
                    updates.$ê“ºset.engines.node = []; // Initialize.
                    if (nodeVersion.previous) updates.$ê“ºset.engines.node.push(nodeVersion.previous);
                    if (nodeVersion.current) updates.$ê“ºset.engines.node.push(nodeVersion.current);
                    if (nodeVersion.forwardCompat.length) updates.$ê“ºset.engines.node = updates.$ê“ºset.engines.node.concat(nodeVersion.forwardCompat);
                    updates.$ê“ºset.engines.node = (updates.$ê“ºset.engines.node.length ? '^' : '') + updates.$ê“ºset.engines.node.join(' || ^');
                }
                if (Object.hasOwn(updates.$ê“ºset?.engines || {}, 'npm')) {
                    updates.$ê“ºset.engines.npm = []; // Initialize.
                    if (nodeVersion.npm.previous) updates.$ê“ºset.engines.npm.push(nodeVersion.npm.previous);
                    if (nodeVersion.npm.current) updates.$ê“ºset.engines.npm.push(nodeVersion.npm.current);
                    if (nodeVersion.npm.forwardCompat.length) updates.$ê“ºset.engines.npm = updates.$ê“ºset.engines.npm.concat(nodeVersion.npm.forwardCompat);
                    updates.$ê“ºset.engines.npm = (updates.$ê“ºset.engines.npm.length ? '^' : '') + updates.$ê“ºset.engines.npm.join(' || ^');
                }
            }
            if ('./package.json' === relPath && (await isPkgRepo('clevercanyon/dev-deps'))) {
                if (updates.$ê“ºdefaults?.['devDependenciesê“º@clevercanyon/dev-deps']) {
                    delete updates.$ê“ºdefaults['devDependenciesê“º@clevercanyon/dev-deps'];
                }
                if ($is.array(updates.$ê“ºunset)) {
                    updates.$ê“ºunset.push('devDependenciesê“º@clevercanyon/dev-deps');
                } else {
                    updates.$ê“ºunset = ['devDependenciesê“º@clevercanyon/dev-deps'];
                }
            }
            $obj.patchDeep(json, updates); // Potentially declarative ops.
            const prettierConfig = { ...(await $prettier.resolveConfig(path.resolve(projDir, relPath))), parser: 'json' };
            await fsp.writeFile(path.resolve(projDir, relPath), await $prettier.format($json.stringify(json, { pretty: true }), prettierConfig));
        }
    }

    /**
     * Recompiles static configurations using latest dotfiles.
     */
    log($chalk.green('Recompiling static configurations using latest dotfiles.'));

    await (await import(path.resolve(projDir, './dev/.files/bin/vscode/index.mjs'))).default({ projDir });
    await (await import(path.resolve(projDir, './dev/.files/bin/gitattributes/index.mjs'))).default({ projDir });
    await (await import(path.resolve(projDir, './dev/.files/bin/gitignore/index.mjs'))).default({ projDir });
    await (await import(path.resolve(projDir, './dev/.files/bin/npmignore/index.mjs'))).default({ projDir });
    await (await import(path.resolve(projDir, './dev/.files/bin/dockerignore/index.mjs'))).default({ projDir });
    await (await import(path.resolve(projDir, './dev/.files/bin/vscodeignore/index.mjs'))).default({ projDir });
    await (await import(path.resolve(projDir, './dev/.files/bin/prettierignore/index.mjs'))).default({ projDir });
    await (await import(path.resolve(projDir, './dev/.files/bin/browserslist/index.mjs'))).default({ projDir });
    await (await import(path.resolve(projDir, './dev/.files/bin/tsconfig/index.mjs'))).default({ projDir });
    await (await import(path.resolve(projDir, './dev/.files/bin/wrangler/index.mjs'))).default({ projDir });
};
