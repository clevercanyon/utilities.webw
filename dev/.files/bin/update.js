#!/usr/bin/env node
/**
 * Update CLI.
 *
 * @note PLEASE DO NOT EDIT THIS FILE!
 * @note This entire file will be updated automatically.
 * @note Instead of editing here, please review <https://github.com/clevercanyon/skeleton>.
 */
/* eslint-env es2021, node */

import fs from 'node:fs';
import os from 'node:os';
import path from 'node:path';
import fsp from 'node:fs/promises';

import chalk from 'chalk';
import { dirname } from 'desm';
import spawn from 'spawn-please';
import { globbyStream } from 'globby';

import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';

const __dirname = dirname(import.meta.url);

const projsDir = path.resolve(__dirname, '../../../..');
const projDir = path.resolve(__dirname, '../../..');

const envsDir = path.resolve(__dirname, '../../../dev/.envs');
const binDir = path.resolve(__dirname, '../../../dev/.files/bin');

const pkgFile = path.resolve(projDir, './package.json');
const pkg = JSON.parse(fs.readFileSync(pkgFile).toString());

const { log } = console;
const echo = process.stdout.write.bind(process.stdout);

const noisySpawnCfg = {
	cwd: projDir, // Displays output while running.
	stdout: (buffer) => echo(chalk.blue(buffer.toString())),
	stderr: (buffer) => echo(chalk.redBright(buffer.toString())),
};
const quietSpawnCfg = { cwd: projDir };

/**
 * Projects command.
 */
class Projects {
	constructor(args) {
		this.args = args;

		(async () => {
			await this.update();

			if (this.args.dryRun) {
				log(chalk.cyanBright('Dry run. This was all a simulation.'));
			}
		})();
	}

	async update() {
		const isAllGlob = '*' === this.args.glob;
		const globStream = globbyStream(this.args.glob, {
			expandDirectories: false,
			onlyDirectories: true,
			absolute: false,
			cwd: projsDir,
			dot: false,
		});
		for await (const projDirSubpath of globStream) {
			const projDir = path.resolve(projsDir, projDirSubpath);
			const projDisplayDir = path.basename(projsDir) + '/' + projDirSubpath;

			const devFilesDir = path.resolve(projDir, './dev/.files');
			const pkgFile = path.resolve(projDir, './package.json');

			if (isAllGlob && !fs.existsSync(devFilesDir)) {
				log(chalk.gray('No `./dev/.files` in: `' + projDisplayDir + '`. Bypassing on all-glob.'));
				continue; // No `./dev/.files` directory.
			}
			if (isAllGlob && !fs.existsSync(pkgFile)) {
				log(chalk.gray('No `./package.json` in: `' + projDisplayDir + '`. Bypassing on all-glob.'));
				continue; // No `./package.json` file.
			}
			if (this.args.run.length) {
				for (const run of this.args.run) {
					log(chalk.green('Running `npm run ' + run + '` in:') + ' ' + chalk.yellow(projDisplayDir));
					if (!this.args.dryRun) {
						await spawn('npm', ['run', run], { ...noisySpawnCfg, cwd: projDir });
					}
				}
			}
			if (this.args.cmdArgs.length) {
				log(chalk.green('Running `' + this.args.cmdArgs.join(' ') + '` in:') + ' ' + chalk.yellow(projDisplayDir));
				if (!this.args.dryRun) {
					await spawn(this.args.cmdArgs.slice(0, 1), ...this.args.cmdArgs.slice(1), { ...noisySpawnCfg, cwd: projDir });
				}
			}
		}
		log(chalk.green('Project updates complete.'));
	}
}

/**
 * Dotfiles command.
 */
class Dotfiles {
	constructor(args) {
		this.args = args;

		(async () => {
			await this.update();

			if (this.args.dryRun) {
				log(chalk.cyanBright('Dry run. This was all a simulation.'));
			}
		})();
	}

	async update() {
		/**
		 * Saves skeleton changes.
		 */
		if ('@clevercanyon/skeleton' === pkg.name && (await u.isGitRepoDirty())) {
			log(chalk.green('Updating `@clevercanyon/skeleton` git repo; `' + (await u.gitCurrentBranch()) + '` branch.'));
			log('    ' + chalk.green('i.e., saving latest skeleton changes before self-update.'));

			if (!this.args.dryRun) {
				await u.gitAddCommitPush();
			}
		}

		/**
		 * Prepares latest skeleton.
		 */
		const s6nRepoURI = 'git@github.com:clevercanyon/skeleton.git';
		const s6nRepoDir = path.resolve(os.tmpdir(), './clevercanyon/7fbdd94a-544e-4914-8955-22ab82bc6b29');

		if (fs.existsSync(s6nRepoDir) && (await u.gitLocalRepoSHA(s6nRepoDir, 'main')) === (await u.gitRemoteRepoSHA(s6nRepoURI, 'main'))) {
			log(chalk.green('Using latest `@clevercanyon/skeleton` from cache.'));
		} else {
			log(chalk.green('Git-cloning, and caching, latest `@clevercanyon/skeleton`.'));
			if (!this.args.dryRun) {
				await fsp.rm(s6nRepoDir, { recursive: true, force: true });
				await fsp.mkdir(s6nRepoDir, { recursive: true }); // Starts fresh.
				await spawn('git', ['clone', s6nRepoURI, s6nRepoDir, '--branch=main', '--depth=1', '--quiet'], { ...noisySpawnCfg, cwd: s6nRepoDir });
			}
			log(chalk.green('Installing `@clevercanyon/skeleton`’s NPM dependencies.'));
			if (!this.args.dryRun) {
				await spawn('npm', ['clean-install', '--include=dev', '--silent'], { ...noisySpawnCfg, cwd: s6nRepoDir });
			}
		}

		/**
		 * Runs updater using files from latest skeleton.
		 */
		log(chalk.green('Running updater using latest `@clevercanyon/skeleton`.'));
		if (!this.args.dryRun) {
			await (await import(path.resolve(s6nRepoDir, './dev/.files/bin/updater/index.js'))).default({ projDir, args: this.args });
		}

		/**
		 * Completes dotfiles update.
		 */
		log(chalk.green('Dotfiles update complete.'));
	}
}

/**
 * Project command.
 */
class Project {
	constructor(args) {
		this.args = args;

		(async () => {
			await this.update();

			if (this.args.dryRun) {
				log(chalk.cyanBright('Dry run. This was all a simulation.'));
			}
		})();
	}

	async update() {
		log(chalk.green('Updating NPM packages.'));
		if (!this.args.dryRun) {
			await u.npmUpdate();
		}

		if (await u.isEnvsRepo()) {
			log(chalk.green('Updating envs build; encrypts vault.'));
			if (!this.args.dryRun) {
				await u.envsBuild(); // Before NPM version patch.
			}
		}
		if (this.args.repos && this.args.pkgs && (await u.isNPMPkgPublishable({ mode: this.args.mode }))) {
			log(chalk.green('NPM package will publish, so patching NPM version prior to build.'));
			if (!this.args.dryRun) {
				await u.npmVersionPatch(); // Git commit(s) + tag.
			}
		}
		log(chalk.green('Updating Vite build; `' + this.args.mode + '` mode.'));
		if (!this.args.dryRun) {
			await u.viteBuild({ mode: this.args.mode });
		}

		if (this.args.repos) {
			if (await u.isGitRepo()) {
				log(chalk.green('Updating git repo; `' + (await u.gitCurrentBranch()) + '` branch.'));
				if (!this.args.dryRun) {
					await u.gitAddCommitPush();
				}
			} else {
				log(chalk.gray('Not a git repo.'));
			}

			if (await u.isEnvsRepo()) {
				log(chalk.green('Updating envs repo.'));
				if (!this.args.dryRun) {
					await u.envsPush();
				}
			} else {
				log(chalk.gray('Not an envs repo.'));
			}

			if (this.args.pkgs) {
				if (await u.isNPMPkgPublishable({ mode: this.args.mode })) {
					log(chalk.green('Publishing NPM package.'));
					if (!this.args.dryRun) {
						await u.npmPublish();
					}
				} else {
					log(chalk.gray('Not an NPM package. Or, not in a publishable state.'));
				}
			}
		}
		log(chalk.green('Project update complete.'));
	}
}

/**
 * Utilities.
 */
class u {
	/*
	 * Git utilities.
	 */

	static async isGitRepo() {
		try {
			return 'true' === String(await spawn('git', ['rev-parse', '--is-inside-work-tree'], quietSpawnCfg)).trim();
		} catch {
			return false;
		}
	}

	static async isGitRepoDirty() {
		try {
			return (await u.isGitRepo()) && '' !== String(await spawn('git', ['status', '--short'], quietSpawnCfg)).trim();
		} catch {
			return false;
		}
	}

	static async gitChange() {
		await fsp.writeFile(path.resolve(projDir, './.gitchange'), String(Date.now()));
	}

	static async gitAddCommit(message = 'Robotic update.') {
		await u.gitChange(); // Force a change.
		await spawn('git', ['add', '--all'], noisySpawnCfg);
		await spawn('git', ['commit', '--message', message], noisySpawnCfg);
	}

	static async gitAddCommitPush(message = 'Robotic update.') {
		await u.gitChange(); // Force a change.
		const branch = await u.gitCurrentBranch();

		await spawn('git', ['add', '--all'], noisySpawnCfg);
		await spawn('git', ['commit', '--message', message], noisySpawnCfg);

		await spawn('git', ['push', '--set-upstream', 'origin', branch], noisySpawnCfg);
		await spawn('git', ['push', 'origin', '--tags'], noisySpawnCfg);
	}

	static async gitCurrentBranch() {
		return (await u.isGitRepo()) ? String(await spawn('git', ['symbolic-ref', '--short', '--quiet', 'HEAD'], quietSpawnCfg)).trim() : '';
	}

	static async gitLocalRepoSHA(repoDir, branch) {
		return String(await spawn('git', ['rev-parse', branch], { ...quietSpawnCfg, cwd: repoDir }))
			.trim()
			.toLowerCase();
	}

	static async gitRemoteRepoSHA(repoURI, branch) {
		return String(await spawn('git', ['ls-remote', repoURI, branch], { ...quietSpawnCfg, cwd: os.tmpdir() }))
			.trim()
			.toLowerCase()
			.split(/\s+/u)[0];
	}

	/*
	 * Env utilities.
	 */

	static async isEnvsRepo() {
		return (
			(await u.isGitRepo()) &&
			fs.existsSync(path.resolve(projDir, './.env.me')) &&
			fs.existsSync(path.resolve(projDir, './.env.vault')) &&
			fs.existsSync(path.resolve(envsDir, './.env'))
		);
	}

	static async envsPush() {
		await spawn(path.resolve(binDir, './envs.js'), ['push'], quietSpawnCfg);
	}

	static async envsBuild() {
		await spawn(path.resolve(binDir, './envs.js'), ['build'], quietSpawnCfg);
	}

	/*
	 * NPM utilities.
	 */

	static async isNPMPkg() {
		return (await u.isGitRepo()) && false === pkg.private;
	}

	static async isNPMPkgPublishable(opts = { mode: 'prod' }) {
		return (await u.isNPMPkg()) && 'main' === (await u.gitCurrentBranch()) && 'prod' === opts.mode;
	}

	static async npmUpdate() {
		await spawn('npm', ['update', '--include=dev', '--silent'], quietSpawnCfg);
	}

	static async npmVersionPatch() {
		if (await u.isGitRepoDirty()) await u.gitAddCommit();
		await spawn('npm', ['version', 'patch'], noisySpawnCfg);
	}

	static async npmPublish() {
		await spawn('npm', ['publish'], noisySpawnCfg);
	}

	/*
	 * Vite utilities.
	 */

	static async viteBuild(opts = { mode: 'prod' }) {
		await spawn('npx', ['vite', 'build', '--mode', opts.mode], noisySpawnCfg);
		await spawn('npx', ['tsc'], noisySpawnCfg); // TypeScript types.
	}
}

/**
 * Yargs ⛵🏴‍☠
 *
 * @see http://yargs.js.org/docs/
 */
(async () => {
	await yargs(hideBin(process.argv))
		.command(
			['projects'],
			'Updates multiple projects.',
			{
				glob: {
					type: 'string',
					requiresArg: true,
					demandOption: false,
					default: '*', // Default is all projects.
					description: 'Glob matching is relative to `' + projsDir + '` and finds directories only.',
				},
				run: {
					type: 'array',
					requiresArg: true,
					demandOption: false,
					default: [],
					description: 'Scripts to `npm run` in each project directory.',
				},
				cmdArgs: {
					type: 'array',
					requiresArg: true,
					demandOption: false,
					default: [],
					description: 'Arbitrary command + arguments to run in each project directory.',
				},
				dryRun: {
					type: 'boolean',
					requiresArg: false,
					demandOption: false,
					default: false,
					description: 'Dry run?',
				},
			},
			(args) => new Projects(args),
		)
		.command(
			['dotfiles'],
			'Updates project dotfiles.',
			{
				skeletonUpdatesOthers: {
					type: 'boolean',
					requiresArg: false,
					demandOption: false,
					default: false,
					description: 'Updating `@clevercanyon/skeleton` also updates others? Such as `skeleton-dev-deps` and `*.fork`s.',
				},
				dryRun: {
					type: 'boolean',
					requiresArg: false,
					demandOption: false,
					default: false,
					description: 'Dry run?',
				},
			},
			(args) => new Dotfiles(args),
		)
		.command(
			['project'],
			'Updates NPM packages + optionally pushes to repos + optionally publishes packages.',
			{
				repos: {
					type: 'boolean',
					requiresArg: false,
					demandOption: false,
					default: false,
					description: 'Push to project repos?',
				},
				pkgs: {
					type: 'boolean',
					requiresArg: false,
					demandOption: false,
					default: false,
					implies: ['repos'],
					description: 'Publish project packages?',
				},
				mode: {
					type: 'string',
					requiresArg: true,
					demandOption: false,
					default: 'prod',
					choices: ['dev', 'ci', 'stage', 'prod'],
					description: 'Build and env mode.',
				},
				dryRun: {
					type: 'boolean',
					requiresArg: false,
					demandOption: false,
					default: false,
					description: 'Dry run?',
				},
			},
			(args) => new Project(args),
		)
		.strict()
		.help()
		.parse();
})();
