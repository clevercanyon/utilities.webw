#!/usr/bin/env node
/**
 * Madrun config file.
 *
 * Madrun is not aware of this config file's location.
 *
 * @note PLEASE DO NOT EDIT THIS FILE!
 * @note This entire file will be updated automatically.
 * @note Instead of editing here, please review <https://github.com/clevercanyon/skeleton>.
 */

import fs from 'node:fs';
import fsp from 'node:fs/promises';
import path from 'node:path';
import { $chalk } from '../../../../../node_modules/@clevercanyon/utilities.node/dist/index.js';
import { $app, $brand, $env, $fn, $is, $json, $url } from '../../../../../node_modules/@clevercanyon/utilities/dist/index.js';
import u from '../../../resources/utilities.mjs';
import getWranglerSettings from '../../wrangler/resources/settings.mjs';

/**
 * Defines event handlers.
 */
export default {
    /**
     * `$ madrun new` events.
     */
    'on::madrun:default:new': {
        cmds: [
            /**
             * Installs new project.
             */
            ['npx', '@clevercanyon/madrun', 'install', 'project'],

            /**
             * Configures new project.
             */
            async ({ args }) => {
                /**
                 * Propagates env vars.
                 */
                await u.propagateUserEnvVars();

                /**
                 * Deletes Dotenv Vault associated with template.
                 */
                u.log($chalk.green('Removing `./env.{me,vault}` files.'));
                await fsp.rm(path.resolve(u.projDir, './.env.me'), { force: true });
                await fsp.rm(path.resolve(u.projDir, './.env.vault'), { force: true });

                /**
                 * Initializes a few variables.
                 */
                u.log($chalk.green('Configuring project variables.'));

                // @todo Can we use `u.projsDir` here?
                const _parentDirBasename = path.basename(path.dirname(u.projDir));
                const _dirBasename = path.basename(u.projDir);

                const _maybeParentDirBrand = $fn.try(() => $brand.get('@' + _parentDirBasename + '/' + _dirBasename))();
                const _parentDirOwner = $is.brand(_maybeParentDirBrand) ? _maybeParentDirBrand.org.slug : _parentDirBasename;

                const pkgName = args.pkgName || '@' + _parentDirOwner + '/' + _dirBasename;
                const pkgSlug = $app.pkgSlug(pkgName); // Slug from `@org/[slug]` in a scoped package, or `slug` from an unscoped package.

                const repoOwner = (/^@/u.test(pkgName) && /[^@/]\/[^@/]/u.test(pkgName) ? pkgName.replace(/^@/u, '').split('/')[0] : '') || _parentDirOwner;
                const repoName = (/^@/u.test(pkgName) && /[^@/]\/[^@/]/u.test(pkgName) ? pkgName.replace(/^@/u, '').split('/')[1] : '') || _dirBasename;

                u.log($chalk.gray($json.stringify({ pkgName, pkgSlug, repoOwner, repoName }, { pretty: true })));

                /**
                 * Updates `./package.json` file.
                 */
                u.log($chalk.green('Updating `./package.json` properties.'));
                await u.updatePkg({
                    name: pkgName, // e.g., `@org/[slug]` forms a package name.
                    repository: 'https://github.com/' + $url.encode(repoOwner) + '/' + $url.encode(repoName),
                    homepage: 'https://github.com/' + $url.encode(repoOwner) + '/' + $url.encode(repoName) + '#readme',
                    bugs: 'https://github.com/' + $url.encode(repoOwner) + '/' + $url.encode(repoName) + '/issues',

                    $unset: /* Effectively resets these to default values. */ [
                        'private', //
                        'publishConfig.access',

                        'version',
                        'license',
                        'description',
                        'funding',
                        'keywords',

                        'author',
                        'contributors',

                        'config.c10n.&.github.teams',
                        'config.c10n.&.github.labels',
                        'config.c10n.&.github.configVersion',
                        'config.c10n.&.github.envsVersion',

                        'config.c10n.&.npmjs.teams',
                        'config.c10n.&.npmjs.configVersions',
                    ],
                    ...(args.pkg ? { $set: { private: false } } : {}),
                    ...(args.pkg && args.public ? { $set: { 'publishConfig.access': 'public' } } : {}),
                });

                /**
                 * Acquires and logs our newly-updated `./package.json` data.
                 */
                u.log($chalk.gray($json.stringify(u.pkg(), { pretty: true })));

                /**
                 * Gets Wrangler settings now that we have valid `./package.json` data.
                 */
                const wranglerSettings = await getWranglerSettings();

                /**
                 * Updates `./dev/.envs`, if applicable.
                 */
                if (fs.existsSync(u.envsDir)) {
                    u.log($chalk.green('Updating `./dev/.envs`.'));
                    const envFiles = await u.envFiles();

                    await fsp
                        .readFile(envFiles.main)
                        .then((buffer) => buffer.toString())
                        .then(async (contents) => {
                            if (['cma'].includes(u.pkgBuildAppType) && 'cfw' === u.pkgBuildTargetEnv) {
                                contents = contents.replace(/^(BASE_PATH)\s*=\s*[^\r\n]*$/gmu, "$1='/" + wranglerSettings.defaultWorkerShortName + "'");
                                //
                            } else if (['spa', 'mpa'].includes(u.pkgBuildAppType) && 'cfp' === u.pkgBuildTargetEnv) {
                                contents = contents.replace(/^(BASE_PATH)\s*=\s*[^\r\n]*$/gmu, "$1='' # No base path.");
                            }
                            u.log($chalk.gray('Updating `./' + path.relative(u.projDir, envFiles.main) + '`.'));
                            await fsp.writeFile(envFiles.main, contents);
                        })
                        .catch((thrown) => {
                            if (!$is.error(thrown) || 'ENOENT' !== thrown.code) throw thrown;
                        });

                    await fsp
                        .readFile(envFiles.stage)
                        .then((buffer) => buffer.toString())
                        .then(async (contents) => {
                            if (['cma'].includes(u.pkgBuildAppType) && 'cfw' === u.pkgBuildTargetEnv) {
                                contents = contents.replace(/^(BASE_PATH)\s*=\s*[^\r\n]*$/gmu, "$1='/" + wranglerSettings.defaultWorkerStageShortName + "'");
                                contents = contents.replace(/^(APP_BASE_URL)\s*=\s*[^\r\n]*$/gmu, "$1='https://" + wranglerSettings.defaultWorkersDomain + "${BASE_PATH}/'");
                                //
                            } else if (['spa', 'mpa'].includes(u.pkgBuildAppType) && 'cfp' === u.pkgBuildTargetEnv) {
                                contents = contents.replace(
                                    /^(APP_BASE_URL)\s*=\s*[^\r\n]*$/gmu,
                                    "$1='https://" +
                                        wranglerSettings.defaultPagesProjectStageBranchName +
                                        '.' +
                                        wranglerSettings.defaultPagesProjectName +
                                        '.' +
                                        wranglerSettings.defaultPagesDevZoneName +
                                        "${BASE_PATH}/'",
                                );
                            }
                            u.log($chalk.gray('Updating `./' + path.relative(u.projDir, envFiles.stage) + '`.'));
                            await fsp.writeFile(envFiles.stage, contents);
                        })
                        .catch((thrown) => {
                            if (!$is.error(thrown) || 'ENOENT' !== thrown.code) throw thrown;
                        });

                    await fsp
                        .readFile(envFiles.prod)
                        .then((buffer) => buffer.toString())
                        .then(async (contents) => {
                            if (['cma'].includes(u.pkgBuildAppType) && 'cfw' === u.pkgBuildTargetEnv) {
                                contents = contents.replace(/^(APP_BASE_URL)\s*=\s*[^\r\n]*$/gmu, "$1='https://" + wranglerSettings.defaultWorkersDomain + "${BASE_PATH}/'");
                                //
                            } else if (['spa', 'mpa'].includes(u.pkgBuildAppType) && 'cfp' === u.pkgBuildTargetEnv) {
                                contents = contents.replace(
                                    /^(APP_BASE_URL)\s*=\s*[^\r\n]*$/gmu,
                                    "$1='https://" + wranglerSettings.defaultPagesProjectShortName + '.' + wranglerSettings.defaultPagesZoneName + "${BASE_PATH}/'",
                                );
                            }
                            u.log($chalk.gray('Updating `./' + path.relative(u.projDir, envFiles.prod) + '`.'));
                            await fsp.writeFile(envFiles.prod, contents);
                        })
                        .catch((thrown) => {
                            if (!$is.error(thrown) || 'ENOENT' !== thrown.code) throw thrown;
                        });
                }

                /**
                 * Updates `./README.md` file, if applicable.
                 */
                if (fs.existsSync(u.readmeFile)) {
                    u.log($chalk.green('Updating `./README.md`.'));

                    await fsp
                        .readFile(u.readmeFile)
                        .then((buffer) => buffer.toString())
                        .then(async (contents) => {
                            contents = contents.replace(/^(#\s+)(@[^/?#\s]+\/[^/?#\s]+)/gmu, '$1' + pkgName);
                            await fsp.writeFile(u.readmeFile, contents);
                        })
                        .catch((thrown) => {
                            if (!$is.error(thrown) || 'ENOENT' !== thrown.code) throw thrown;
                        });
                }

                /**
                 * Initializes this as a new git repository.
                 */
                u.log($chalk.green('Initializing git repository.'));
                await u.spawn('git', ['init']);

                /**
                 * Updates dotfiles after the above changes.
                 */
                u.log($chalk.green('Updating project dotfiles.'));
                await u.updateDotfiles(/* Recompiles statics. */);

                /**
                 * Updates Vite build after the above changes.
                 */
                u.log($chalk.green('Updating project build directory.'));
                if (await u.isViteBuild()) await u.viteBuild();

                /**
                 * Saves changes made here as first initial commit.
                 */
                u.log($chalk.green('Adding first git commit with project files.'));
                await u.gitAddCommit('Initializing project directory. [n]');

                /**
                 * Attempts to create a remote repository origin at GitHub.
                 */
                if ('clevercanyon' === repoOwner) {
                    if ($env.test('GH_TOKEN') && 'owner' === (await u.gistGetC10NUser()).github?.role) {
                        u.log($chalk.green('Creating remote project repo at GitHub [' + (args.public ? 'public' : 'private') + '].'));
                        await u.spawn('gh', ['repo', 'create', repoOwner + '/' + repoName, '--source', u.projDir, args.public ? '--public' : '--private']);
                    } else {
                        u.log($chalk.green('Configuring a remote repo origin.'));
                        await u.spawn('git', ['remote', 'add', 'origin', 'https://github.com/' + $url.encode(repoOwner) + '/' + $url.encode(repoName) + '.git']);
                    }
                } else if ($env.get('USER_GITHUB_USERNAME', { type: 'string' }) === repoOwner) {
                    if ($env.test('GH_TOKEN')) {
                        u.log($chalk.green('Creating remote project repo at GitHub [' + (args.public ? 'public' : 'private') + '].'));
                        await u.spawn('gh', ['repo', 'create', repoOwner + '/' + repoName, '--source', u.projDir, args.public ? '--public' : '--private']);
                    } else {
                        u.log($chalk.green('Configuring a remote repo origin.'));
                        await u.spawn('git', ['remote', 'add', 'origin', 'https://github.com/' + $url.encode(repoOwner) + '/' + $url.encode(repoName) + '.git']);
                    }
                }

                /**
                 * Signals completion with success.
                 */
                u.log(await u.finaleBox('Success', 'New project ready.'));
            },
        ],
    },
};
