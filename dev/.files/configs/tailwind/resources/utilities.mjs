/**
 * Tailwind utilities.
 *
 * @note PLEASE DO NOT EDIT THIS FILE!
 * @note This entire file will be updated automatically.
 * @note Instead of editing here, please review <https://github.com/clevercanyon/skeleton>.
 *
 * @internal Jiti, which is used by Tailwind to load ESM config files, doesn’t support top-level await and does not support
 * `import.meta.url`. Thus, we cannot use async functionality here, and we cannot use our `u` (utilities). Therefore, we
 * produce an extremely watered-down version of our utilities specifically for Tailwind config files.
 */

import fs from 'node:fs';
import path from 'node:path';
import { $is, $json, $obj, $obp, $to } from '../../../../../node_modules/@clevercanyon/utilities/dist/index.js';

import uꓺexts from '../../../resources/utilities/exts.mjs';
import uꓺomit from '../../../resources/utilities/omit.mjs';

// `__dirname` already exists when loaded by Tailwind via Jiti / commonjs.
// eslint-disable-next-line no-undef -- `__dirname` is not actually missing.
const ___dirname = __dirname; // Current directory.

/**
 * Utilities.
 */
export default class u {
    /**
     * Private static props.
     */

    static #s = { cache: {} };

    /**
     * Public static props.
     */

    // Paths derived from current `projDir`.
    // However, we don't support switches here.

    static projDir = path.resolve(___dirname, '../../../../..');
    static nmDir = path.resolve(u.projDir, './node_modules');
    static pkgFile = path.resolve(u.projDir, './package.json');

    // Package props with getters.

    static get pkgName() {
        return $to.string($obp.get(u.pkg(), 'name', ''));
    }

    // Sub-module resource imports.

    static exts = uꓺexts;
    static omit = uꓺomit;

    /**
     * Synchronous utilities.
     */

    /*
     * Pkg utilities.
     */

    static pkg(...args) {
        let file, opts; // Initialize.

        if (1 === args.length && $is.object(args[0])) {
            file = u.pkgFile; // Default `./package.json` file.
            opts = $obj.defaults({}, args[0], { cache: file === u.pkgFile });
        } else {
            file = args.length ? args[0] : u.pkgFile; // Else default file.
            opts = $obj.defaults({}, args[1] || {}, { cache: file === u.pkgFile });
        }
        u.#s.cache.pkg ??= {}; // Initializes cache.

        if (opts.cache && u.#s.cache.pkg[file]) {
            return u.#s.cache.pkg[file];
        }
        if (!fs.existsSync(file)) {
            throw new Error('Tailwind: u.pkg: Missing `' + file + '`.');
        }
        const pkg = $json.parse(fs.readFileSync(file).toString());

        if (!$is.plainObject(pkg)) {
            throw new Error('Tailwind: u.pkg: Unable to parse `' + file + '`.');
        }
        if (opts.cache || file === u.pkgFile) {
            u.#s.cache.pkg[file] = pkg;
        }
        return pkg; // Package data.
    }
}
