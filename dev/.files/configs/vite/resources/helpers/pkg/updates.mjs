/**
 * `./package.json` property updates.
 *
 * Vite is not aware of this config file's location.
 *
 * @note PLEASE DO NOT EDIT THIS FILE!
 * @note This entire file will be updated automatically.
 * @note Instead of editing here, please review <https://github.com/clevercanyon/skeleton>.
 */

import fs from 'node:fs';
import path from 'node:path';
import { $chalk } from '../../../../../../../node_modules/@clevercanyon/utilities.node/dist/index.js';
import { $mm, $obj } from '../../../../../../../node_modules/@clevercanyon/utilities/dist/index.js';
import u from '../../../../../resources/utilities.mjs';

/**
 * Performs `./package.json` property updates.
 *
 * @param   props Props from vite config file driver.
 *
 * @returns       `./package.json` property updates.
 */
export default async ({ command, isSSRBuild, appType, targetEnv, sideEffects, appEntriesAsProjRelPaths, appEntriesAsSrcSubpaths, appEntriesAsSrcSubpathsNoExt }) => {
    const pkgUpdates = {}; // Initialize.

    if (isSSRBuild) {
        pkgUpdates.type = 'module'; // ESM; always.
        // Regarding `sideEffects`, {@see https://o5p.me/xVY39g}.
        pkgUpdates.sideEffects = u.pkgSideEffects.concat(sideEffects);
    } else {
        pkgUpdates.type = 'module'; // ESM; always.
        pkgUpdates.exports = {}; // Exports object initialization.

        // Regarding `sideEffects`, {@see https://o5p.me/xVY39g}.
        pkgUpdates.sideEffects = ['**/*.' + u.exts.asBracedGlob([...u.exts.byVSCodeLang.css, ...u.exts.byVSCodeLang.scss, ...u.exts.byVSCodeLang.less])];
        pkgUpdates.sideEffects = pkgUpdates.sideEffects.concat(sideEffects);

        if (fs.existsSync(path.resolve(u.srcDir, './resources/initialize.ts'))) {
            pkgUpdates.sideEffects.push('./' + path.relative(u.projDir, path.resolve(u.srcDir, './resources/initialize.ts')));
        }
        if (['spa', 'mpa'].includes(appType) && fs.existsSync(path.resolve(u.srcDir, './resources/hydrate.tsx'))) {
            pkgUpdates.sideEffects.push('./' + path.relative(u.projDir, path.resolve(u.srcDir, './resources/hydrate.tsx')));
        }
        const distDirAsProjRelPath = './' + path.relative(u.projDir, u.distDir); // Relative dist directory path.

        switch (true /* Conditional case handlers. */) {
            case ['spa', 'mpa'].includes(appType): {
                const canonicalHTMLExtRegExp = new RegExp('\\.' + u.exts.asRegExpFrag([...u.exts.byCanonical.html]) + '$', 'ui');
                const appEntryIndexAsSrcSubpath = appEntriesAsSrcSubpaths.find((subpath) => $mm.isMatch(subpath, 'index.' + u.exts.asBracedGlob([...u.exts.byCanonical.html])));
                const appEntryIndexAsSrcSubpathNoExt = appEntryIndexAsSrcSubpath.replace(/\.[^.]+$/u, '');

                if (['spa'].includes(appType) && (!appEntryIndexAsSrcSubpath || !appEntryIndexAsSrcSubpathNoExt)) {
                    throw new Error('Single-page apps must have an `./index.' + u.exts.asBracedGlob([...u.exts.byCanonical.html]) + '` entry point.');
                    //
                } else if (['mpa'].includes(appType) && (!appEntryIndexAsSrcSubpath || !appEntryIndexAsSrcSubpathNoExt)) {
                    throw new Error('Multipage apps must have an `./index.' + u.exts.asBracedGlob([...u.exts.byCanonical.html]) + '` entry point.');
                }
                (pkgUpdates.exports = null), (pkgUpdates.typesVersions = {});
                pkgUpdates.main = pkgUpdates.module = pkgUpdates.unpkg = pkgUpdates.browser = pkgUpdates.types = '';

                for (const appEntryAsProjRelPath of appEntriesAsProjRelPaths) {
                    if (canonicalHTMLExtRegExp.test(appEntryAsProjRelPath)) {
                        pkgUpdates.sideEffects.push(appEntryAsProjRelPath); // The HTML file has side effects.
                        pkgUpdates.sideEffects.push(appEntryAsProjRelPath.replace(canonicalHTMLExtRegExp, '.tsx'));

                        if (fs.existsSync(path.resolve(u.projDir, appEntryAsProjRelPath.replace(canonicalHTMLExtRegExp, '.scss')))) {
                            pkgUpdates.sideEffects.push(appEntryAsProjRelPath.replace(canonicalHTMLExtRegExp, '.scss'));
                        }
                    }
                }
                break; // Stop here.
            }
            case ['cma', 'lib'].includes(appType): {
                const appEntryIndexAsSrcSubpath = appEntriesAsSrcSubpaths.find((subpath) =>
                    $mm.isMatch(subpath, 'index.' + u.exts.asBracedGlob([...u.exts.byDevGroup.sTypeScript, ...u.exts.byDevGroup.sTypeScriptReact])),
                );
                const appEntryIndexAsSrcSubpathNoExt = appEntryIndexAsSrcSubpath.replace(/\.[^.]+$/u, '');

                if (['cma'].includes(appType) && (!appEntryIndexAsSrcSubpath || !appEntryIndexAsSrcSubpathNoExt)) {
                    throw new Error(
                        'Custom apps must have an `./index.' + u.exts.asBracedGlob([...u.exts.byDevGroup.sTypeScript, ...u.exts.byDevGroup.sTypeScriptReact]) + '` entry point.',
                    );
                    //
                } else if (['lib'].includes(appType) && (!appEntryIndexAsSrcSubpath || !appEntryIndexAsSrcSubpathNoExt)) {
                    throw new Error(
                        'Library apps must have an `./index.' + u.exts.asBracedGlob([...u.exts.byDevGroup.sTypeScript, ...u.exts.byDevGroup.sTypeScriptReact]) + '` entry point.',
                    );
                }
                pkgUpdates.exports = {
                    '.': {
                        types: distDirAsProjRelPath + '/types/' + appEntryIndexAsSrcSubpathNoExt + '.d.ts', // First, always.
                        import: distDirAsProjRelPath + '/' + appEntryIndexAsSrcSubpathNoExt + '.js', // ESM module import path.
                        default: distDirAsProjRelPath + '/' + appEntryIndexAsSrcSubpathNoExt + '.js', // Last, always.
                    },
                };
                pkgUpdates.main = distDirAsProjRelPath + '/' + appEntryIndexAsSrcSubpathNoExt + '.js';
                pkgUpdates.module = distDirAsProjRelPath + '/' + appEntryIndexAsSrcSubpathNoExt + '.js';

                pkgUpdates.unpkg = pkgUpdates.module; // Same, same. ESM-only builds.
                pkgUpdates.browser = ['web'].includes(targetEnv) ? pkgUpdates.module : '';

                pkgUpdates.typesVersions = { '>=3.1': { './*': [distDirAsProjRelPath + '/types/*'] } };
                pkgUpdates.types = distDirAsProjRelPath + '/types/' + appEntryIndexAsSrcSubpathNoExt + '.d.ts';

                for (const appEntryAsSrcSubpathNoExt of [...appEntriesAsSrcSubpathsNoExt].sort()) {
                    if (appEntryAsSrcSubpathNoExt === appEntryIndexAsSrcSubpathNoExt) {
                        continue; // i.e., Itâ€™s already been defined as `.` above.
                    }
                    $obj.patchDeep(pkgUpdates.exports, {
                        ['./' + appEntryAsSrcSubpathNoExt]: {
                            types: distDirAsProjRelPath + '/types/' + appEntryAsSrcSubpathNoExt + '.d.ts', // First, always.
                            import: distDirAsProjRelPath + '/' + appEntryAsSrcSubpathNoExt + '.js', // ESM module import path.
                            default: distDirAsProjRelPath + '/' + appEntryAsSrcSubpathNoExt + '.js', // Last, always.
                        },
                    });
                }
                break; // Stop here.
            }
            default: {
                throw new Error('Unexpected `appType`. Failed to update `./package.json` properties.');
            }
        }
    }
    sideEffects.length = 0; // Empty & repopulate by reference.
    pkgUpdates.sideEffects = [...new Set(pkgUpdates.sideEffects)].sort();
    pkgUpdates.sideEffects.forEach((sideEffect) => sideEffects.push(sideEffect));

    if ('build' === command /* Only when building the app. */) {
        u.log($chalk.gray('Updating `type` and `sideEffects` in `./package.json`.'));
        await u.updatePkg({ $set: { type: pkgUpdates.type, sideEffects: pkgUpdates.sideEffects } });
    }
    return { pkgUpdates };
};
